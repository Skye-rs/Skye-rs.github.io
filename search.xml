<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTF-web学习</title>
    <url>/2022/03/09/CTF-web/</url>
    <content><![CDATA[<h2 id="Git泄露">Git泄露</h2>
<p>利用工具-GitHack<br>
<code>git clone git://github.com/BugScanTeam/GitHack.git</code><br>
进入GitHck文件夹，使用python2<br>
<code>python2 GitHack.py http://challenge-c1bea46c13604f27.sandbox.ctfhub.com:10800/.git/</code><br>
还原后的文件在dist/目录下，进入<br>
<code>cd  \dist\challenge-55b6c65232b6b6ab.sandbox.ctfhub.com_10080\</code><br>
在这里检查git提交历史记录log，<code>git log</code>查看日志,可以看到add flag后又remove，所以检查当前版本与上一个版本的区别<code>git diff 版本号</code><br>
<img src="https://cdn.jsdelivr.net/gh/Skye-rs/CDN/image/log.png" alt="log"><br>
找到flag</p>
]]></content>
      <categories>
        <category>CTF学习笔记</category>
        <category>web</category>
        <category>信息泄露</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础学习笔记</title>
    <url>/2022/03/07/PHP%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>
<p>$_SERVER[“PHP_SELF”]是一种超全局变量，返回当前执行脚本的文件名。</p>
<ul>
<li>
<p>“test_form.php” 的页面中有如下表单：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&lt;?php echo <span class="subst">$_SERVER</span>[&quot;</span>PHP_SELF<span class="string">&quot;];?&gt;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>用户输入<code>http://www.example.com/test_form.php</code>转化为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;test_form.php&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>http://www.example.com/test_form.php/**%22%3E%3C**script **%3**Ealer('hacked')**%3C**/script **%3E**</code>则转为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;test_form.php&quot;</span>/&gt;&lt;script&gt;<span class="title function_ invoke__">alert</span>(<span class="string">&#x27;hacked&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>执行javascript代码。</p>
</li>
</ul>
</li>
<li>
<p>htmlspecialchars()把特殊字符转换为HTML实体，&lt; 和 &gt; 之类的 HTML 字符会被替换为 &amp;lt; 和 &amp;gt; 。这样可防止攻击者通过在表单中注入 HTML 或 JavaScript 代码（跨站点脚本攻击）对代码进行利用。<br>
<s>如何攻击该方式？</s></p>
</li>
<li>
<p>检查函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 定义变量并设置为空值</span></span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$email</span> = <span class="variable">$gender</span> = <span class="variable">$comment</span> = <span class="variable">$website</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;REQUEST_METHOD&quot;</span>] == <span class="string">&quot;POST&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$name</span> = <span class="title function_ invoke__">test_input</span>(<span class="variable">$_POST</span>[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line"><span class="variable">$email</span> = <span class="title function_ invoke__">test_input</span>(<span class="variable">$_POST</span>[<span class="string">&quot;email&quot;</span>]);</span><br><span class="line"><span class="variable">$website</span> = <span class="title function_ invoke__">test_input</span>(<span class="variable">$_POST</span>[<span class="string">&quot;website&quot;</span>]);</span><br><span class="line"><span class="variable">$comment</span> = <span class="title function_ invoke__">test_input</span>(<span class="variable">$_POST</span>[<span class="string">&quot;comment&quot;</span>]);</span><br><span class="line"><span class="variable">$gender</span> = <span class="title function_ invoke__">test_input</span>(<span class="variable">$_POST</span>[<span class="string">&quot;gender&quot;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_input</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">stripslashes</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>PHP学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>JS基本语法学习</title>
    <url>/2022/03/07/JS-1/</url>
    <content><![CDATA[<ul>
<li>
<p>创建对象</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&quot;Bill&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="string">&quot;Gates&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">62</span>,</span><br><span class="line">    <span class="attr">eyeColor</span>:<span class="string">&quot;blue&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象是易变的，定义<code>var x=person</code>,x与person指向同一对象，二者同时改变。</p>
</li>
<li>
<p>访问对象<br>
<code>person.age 或 person[&quot;age&quot;]</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python学习笔记】- 基本数据类型</title>
    <url>/2022/02/15/python-1/</url>
    <content><![CDATA[<h2 id="数字类型及操作">数字类型及操作</h2>
<h3 id="整数">整数</h3>
<p>==整数无限制==</p>
<ul>
<li>
<p>进制</p>
<ul>
<li>
<p>十进制 1010，99，-217</p>
</li>
<li>
<p>二进制 0b或0B开头</p>
</li>
<li>
<p>八进制 0o或0O</p>
</li>
<li>
<p>十六进制 0x或0X</p>
</li>
</ul>
</li>
</ul>
<h3 id="浮点数">浮点数</h3>
<p>==浮点数间运算存在不确定尾数==（用二进制表示有误差）</p>
<ul>
<li>
<p>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">round</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span></span></span></span> 浮点数间运算比较</p>
<ul>
<li>
<p>不确定尾数一般发生在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>16</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>左右</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">round(x,d):</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span></span></span></span>对x进行四舍五入，d是小数截取位数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">1</span>) == <span class="number">0.3</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>采用科学计数法表示浮点数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Hexo搭建属于自己的免费博客</title>
    <url>/2022/02/13/hexo_github/</url>
    <content><![CDATA[<p><strong>用以记录我搭建博客的完整流程：</strong></p>
<p>我选用了github+hexo框架，配以vscode作为编辑器一体化配置。基于github page生成的个人博客可以保证稳定性（不会莫名挂了），使用vscode本地编写md文件再直接使用hexo命令渲染推送到公网也比较方便。</p>
<h2 id="Github账号准备">Github账号准备</h2>
<h3 id="新建仓库命名为github账户名-github-io">新建仓库命名为<code>github账户名.github.io</code></h3>
<h3 id="github远程仓库与本机连接">github远程仓库与本机连接</h3>
<h2 id="Node准备">Node准备</h2>
<h2 id="安装Hexo">安装Hexo</h2>
<h2 id="创建网站">创建网站</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>至此你的博客已经可以被他人以<a href="https://xxxx.github.io">https://xxxx.github.io</a>的形式访问到了，个人博客的雏形已基本完成，接下来是进一步优化。</p>
<h2 id="皮肤">皮肤</h2>
<h2 id="设置评论系统">设置评论系统</h2>
<h2 id="CDN加速">CDN加速</h2>
]]></content>
      <categories>
        <category>环境配置</category>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>【BUAA 18级数据结构第二题】后缀表达式转中缀表达式&amp;表达式计算</title>
    <url>/2022/02/14/%E3%80%90BUAA%2018%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E9%A2%98%E3%80%91%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1>题面</h1>
<ul>
<li>【问题描述】<br>
从控制台输入一合法的后缀表达式，其中的运算符只包括+、-、*、/，运算数都是大于等于 0 的整数（除数不为零），按要求输出计算结果，或输出计算结果和相对应的中缀表达式。输出中缀表达式时只包含最少数目的圆括号（即在生成的中缀表达式中若去掉一对括号，则其将不能够转换回输入的后缀表达式）。输出计算结果时，小数点后保留两位，例如：10/3 的结果为 3.33<br>
假如输入的后缀表达式为：<br>
100 25 + 27 25 - / 248 + 201 -<br>
其相对应的中缀表达式为：<br>
(100+25)/(27-25)+248-201<br>
计算结果为 109.50。</li>
<li>【输入形式】<br>
首先从控制台输入一个合法的后缀表达式（长度不超过 200 个字符），其中的运算符、运算数之间都以一个空格分隔。然后在下一行输入一个整数 1 或 2 表示计算要求（1 表示只输出计算结果；2 表示输出对应的中缀表达式和计算结果）。<br>
【输出形式】<br>
若输入的计算要求为 1，则只将计算结果输出到控制台，小数点后保留两位；若输入的计算要求为 2，则先将后缀表达式对应的中缀表达式输出到控制台（其中添加的小括号都为英文小括号，表达式中不包含任何空白符），然后在下一行输出计算结果，小数点后保留两位。<br>
【样例 1 输入】<br>
100 25 + 27 25 - / 248 + 201 -<br>
1<br>
【样例 1 输出】<br>
109.50<br>
【样例 2 输入】<br>
100 25 + 27 25 - / 248 + 201 -<br>
2<br>
【样例 2 输出】<br>
(100+25)/(27-25)+248-201<br>
109.50<br>
【样例 1 和 2 说明】两样例输入了相同的后缀表达式。按计算要求，样例 1 只输出了计算结果；样例 2 输出了转换后的（包含最少括号的）中缀表达式和计算结果。按照后缀表达式的计算语义，当转换为中缀表达式时，前两个运算符连成的表达式100+25 和 27-25 都要加上小括号。<br>
【样例 3 输入】<br>
100 25 + 2 58 42 + * /<br>
2<br>
【样例 3 输出】<br>
(100+25)/(2*(58+42))<br>
0.63<br>
【样例 3 说明】按照后缀表达式的计算语义，生成中缀表达时表达式 2*(58+42)外应该加上小括号，否则两个表达式计算顺序不一致。</li>
<li><strong>后缀转中缀算法提示</strong>：<br>
1、每步进行后缀表达式计算时，除了要保存计算结果外，还应保存对应的（以字符串形式表示的）运算符和中缀表达式。<br>
2、在进行后缀表达式计算时，当前运算符的优先级<strong>大于左运算对象运算符优先级</strong>，则生成对应的中缀表达式时左运算对象对应的中缀表达式应加括号；当前运算符的优先级<strong>大于或等于右运算对象运算符优先级</strong>时，则生成对应的中缀表达式时右运算对象对应的中缀表达式应加括号。其它情况则不用加括号。<br>
以样例 2 为例，在进行后缀表达式计算时：<br>
• 第一次进行’+‘运算时，左运算对象为 100，右为 25，运算结果为 125、运算符为’+‘、对应中缀表达式为 100+25；<br>
• 第二次进行’-‘运算时，左运算对象为 27，右为 25，运算结果为 2、运算符为’-‘、对应中缀表达式为 27-25；<br>
• 第三次进行’/‘运算时，左运算对象为 125、对应运算符为’+‘、对应中缀表达式为 100+25，由于’/‘优先级高于’+‘，因此生成对应中缀表达式时 100+25应加括号；右运算对象为 2、对应运算符为’-‘、对应中缀表达式为 27-25，由于’/‘优先级高于’-‘，因此生成对应中缀表达式时 27-25 也应加括号。该步运算结果为 62.5、运算符为’/'、对应中缀表达式为(100+25)/(27-25)；<br>
• 以此类推</li>
</ul>
<h1>思路分析</h1>
<ul>
<li>首先1情况很好实现，搞一个数据栈，从头开始读表达式，因为是后缀表达式，所以可以直接莫伊。即遇到数字就压入栈，遇到运算符就将栈顶的两个数字出栈进行运算，运算结果入栈。</li>
<li><s>情况2折磨我良久QAQ</s>注意到算法提示中的描述，应该意识到这也是一个栈操作，区别在于栈内的元素是表达式，上述描述中<strong>左运算对象</strong>对应<strong>次栈顶元素</strong>，<strong>右运算对象</strong>对应<strong>栈顶元素</strong>，（单独的数也看作是一个表达式）每遇到运算符就将栈顶的两个元素弹出与运算符重新组合，组合结果入栈，这个过程和1是可以同步进行的。</li>
</ul>
<h2 id="总体规划有了，我们需要考虑的细节是：">总体规划有了，我们需要考虑的细节是：</h2>
<ol>
<li>怎么加括号</li>
<li>怎么组合新的表达式</li>
</ol>
<ul>
<li>加括号其实就是考虑先算谁，先算乘除再算加减肯定没问题，如果遇到优先级高一级的就直接加括号，但注意==大于或等于右运算对象运算符优先级==这一句中的等于，就是在问你从左往右算的时候先算谁（给谁加括号），优先级相等的情况有：–、++、±、**、//、*/ ，如果是前5种，那么运算顺序没有影响，所以不用加括号,而最后一种 <strong>5*6/3和(5*6)/3</strong>结果是不一样的，所以为了方便我们可以认为*的优先级低于/;<br>
这样只要判断表达式的运算符（表达式的运算符需要在每次组合完后更新）的优先级是否低于当前运算符，低于就加；</li>
<li>组合新表达式嘛，本蒻蒟笨笨的复制粘贴了一遍，<em><s>懒得动脑子了</s></em><br>
基于这样的考虑，就可以有这样的一个表达式栈的结构，  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">infix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> item[MAXSIZE*<span class="number">2</span>];</span><br><span class="line">	<span class="type">char</span> flag;</span><br><span class="line">&#125; ans_stack[MAXSIZE];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="更多细节写注释里了">更多细节写注释里了~</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 205</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">infix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> item[MAXSIZE*<span class="number">2</span>];</span><br><span class="line">	<span class="type">char</span> flag;</span><br><span class="line">&#125; ans_stack[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> numSTACK[MAXSIZE];</span><br><span class="line"><span class="type">int</span> num[MAXSIZE],cnt;		<span class="comment">/*这个num数组用来储存输入中的顺序，</span></span><br><span class="line"><span class="comment">							因为在表达式栈中为了简洁操作用&#x27;n&#x27;来代替数字，</span></span><br><span class="line"><span class="comment">							而后缀表达式转为中缀的过程中数字顺序没有变化，</span></span><br><span class="line"><span class="comment">							所以可以输出的时候遇到n直接从数学序列中对应输出*/</span></span><br><span class="line"><span class="type">char</span> opSTACK[MAXSIZE];</span><br><span class="line"><span class="type">int</span> numTOP,ansTop;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	numTOP = <span class="number">-1</span>;</span><br><span class="line">	ansTop = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CAL</span><span class="params">(<span class="type">char</span> op)</span>; <span class="comment">//计算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLowerThan</span><span class="params">(<span class="type">char</span> a,<span class="type">char</span> b)</span><span class="comment">//判断a的优先级是否小于b</span></span><br><span class="line">&#123;<span class="comment">//判断优先级 注意*和/</span></span><br><span class="line">	<span class="keyword">return</span> ((a == <span class="string">&#x27;+&#x27;</span> || a == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (b == <span class="string">&#x27;*&#x27;</span> || b == <span class="string">&#x27;/&#x27;</span>))||(a==<span class="string">&#x27;*&#x27;</span>&amp;&amp;b==<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addBrackets</span><span class="params">(<span class="type">char</span> flag, <span class="type">char</span> s[],<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Init();</span><br><span class="line">	<span class="type">char</span> in[<span class="number">300</span>];</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i, aim, now = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">	gets(in);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;aim);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; in[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		c = in[i];</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;<span class="comment">//读入数字常用手段</span></span><br><span class="line">			now *= <span class="number">10</span>, now += c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (flag)<span class="comment">//但注意如果没读入的话now一直是0 都入栈了 会有一些离谱的输出所以要判断有没有读数字</span></span><br><span class="line">			&#123;	numSTACK[++numTOP] =(<span class="type">double</span>) now;</span><br><span class="line">				ans_stack[++ansTop].item[<span class="number">0</span>] = <span class="string">&#x27;n&#x27;</span>;<span class="comment">//用n代替数字</span></span><br><span class="line">				ans_stack[ansTop].flag = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//如果是单个数字作为表达式就不用加括号，直接标记</span></span><br><span class="line">				num[cnt++] = now;<span class="comment">//作为输出的对应表</span></span><br><span class="line">			&#125;</span><br><span class="line">			now = <span class="number">0</span>;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//先给左右运算对象加括号</span></span><br><span class="line">			addBrackets(ans_stack[ansTop - <span class="number">1</span>].flag, ans_stack[ansTop - <span class="number">1</span>].item, c);</span><br><span class="line">			addBrackets(ans_stack[ansTop].flag, ans_stack[ansTop].item, c);</span><br><span class="line">			<span class="comment">//然后组合，左 运算符 右连起来</span></span><br><span class="line">			<span class="type">int</span> len = <span class="built_in">strlen</span>(ans_stack[ansTop - <span class="number">1</span>].item);</span><br><span class="line">			ans_stack[ansTop - <span class="number">1</span>].item[len] = c;</span><br><span class="line">			len++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;ans_stack[ansTop].item[j];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				ans_stack[ansTop - <span class="number">1</span>].item[len++] = ans_stack[ansTop].item[j];</span><br><span class="line">			&#125;</span><br><span class="line">			ans_stack[ansTop - <span class="number">1</span>].item[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			ans_stack[ansTop - <span class="number">1</span>].flag = c;<span class="comment">//重置当前表达式的运算符</span></span><br><span class="line">			<span class="built_in">memset</span>(ans_stack[ansTop].item, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(ans_stack[ansTop].item));</span><br><span class="line">			<span class="comment">//注意出栈一定要清空数组</span></span><br><span class="line">			ansTop--;</span><br><span class="line">			CAL(c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (aim == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ans_stack[<span class="number">0</span>].item[i];i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans_stack[<span class="number">0</span>].item[i]==<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num[cnt++]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ans_stack[<span class="number">0</span>].item[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, numSTACK[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addBrackets</span><span class="params">(<span class="type">char</span> flag, <span class="type">char</span> s[],<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(flag!=<span class="string">&#x27;#&#x27;</span>&amp;&amp;isLowerThan(flag,c))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = len<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">			s[j + <span class="number">1</span>] = s[j];</span><br><span class="line">		s[<span class="number">0</span>] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">		s[len + <span class="number">1</span>] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">		s[len + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CAL</span><span class="params">(<span class="type">char</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">		numSTACK[numTOP - <span class="number">1</span>] = numSTACK[numTOP - <span class="number">1</span>] * numSTACK[numTOP];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">		numSTACK[numTOP - <span class="number">1</span>] = numSTACK[numTOP - <span class="number">1</span>] / numSTACK[numTOP];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">		numSTACK[numTOP - <span class="number">1</span>] = numSTACK[numTOP - <span class="number">1</span>] + numSTACK[numTOP];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">		numSTACK[numTOP - <span class="number">1</span>] = numSTACK[numTOP - <span class="number">1</span>] - numSTACK[numTOP];</span><br><span class="line">	numTOP--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>表达式</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法篇】排序——快速排序（c语言）</title>
    <url>/2022/02/15/%E3%80%90%E7%AE%97%E6%B3%95%E7%AF%87%E3%80%91%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>【算法篇】排序——快速排序（c语言）</h1>
<h2 id="核心思想">核心思想</h2>
<ul>
<li>排序算法的思想非常简单，在待排序的数列中，首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第 1 个数字作为基准数（其实可以<strong>随便选</strong>）。然后把这个待排序的数列中小于基准数的元素移动到它的左边，大于它的移到右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别重复上述步骤，直到各个分区只有一个数时为止。</li>
</ul>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = in[(l + r) / <span class="number">2</span>];<span class="comment">//这里是选择中间值作为基准</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (in[i] &lt; mid)</span><br><span class="line">            i++; <span class="comment">//找到左边比基准值大的数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (in[j] &gt; mid)</span><br><span class="line">            j--; <span class="comment">//找右边小的</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;(in[i]), &amp;(in[j])); <span class="comment">//交换使左边的小右边的大</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;j)</span><br><span class="line">        quick_sort(l, j);<span class="comment">//排左边</span></span><br><span class="line">    <span class="keyword">if</span>(r&gt;i)</span><br><span class="line">        quick_sort(i, r);<span class="comment">//排右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><s>当然了一般情况下不用自己写（毕竟有现成的）</s><br>
<em>来看一下炒鸡好用的qsort函数</em></p>
<h2 id="qsort函数的用法">qsort函数的用法</h2>
<h3 id="函数声明">函数声明</h3>
<blockquote>
<p>void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void <em>, const void</em>))</p>
</blockquote>
<h3 id="参数说明">参数说明</h3>
<blockquote>
<p>base-- 指向要排序的数组的第一个元素的指针。<br>
nitems-- 由 base 指向的数组中元素的个数。<br>
size-- 数组中每个元素的大小，以字节为单位。<br>
==compar-- 用来比较两个元素的函数，即函数指针（回调函数）==</p>
</blockquote>
<ul>
<li>compar函数的形式决定了对谁排序*</li>
</ul>
<p>int compar(const void<em>p1, const void</em>p2);</p>
<table>
<thead>
<tr>
<th>compar函数的返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;0</td>
<td>p1所指向元素将被排在p2所指向元素的左面</td>
</tr>
<tr>
<td>=0</td>
<td>p1所指向元素与p2所指向元素的顺序不确定</td>
</tr>
<tr>
<td>&gt;0</td>
<td>p1所指向元素会被排在p2所指向元素的右面</td>
</tr>
</tbody>
</table>
<h3 id="具体用法说明">具体用法说明</h3>
<ul>
<li>对一维数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*a,<span class="type">const</span> <span class="type">void</span>*b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a-*(<span class="type">int</span>*)b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>对二维数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*a,<span class="type">const</span> <span class="type">void</span>*b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">int</span>*)a)[<span class="number">0</span>]-((<span class="type">int</span>*)b)[<span class="number">0</span>];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>对字符串</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Comp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*p1,<span class="type">const</span> <span class="type">void</span>*p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>((<span class="type">char</span>*)p2,(<span class="type">char</span>*)p1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[MAX1][MAX2];</span><br><span class="line">    initial(a);</span><br><span class="line">    qsort(a,lenth,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]),Comp);</span><br><span class="line">    <span class="comment">//lenth为数组a的长度 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对结构体一级排序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> data;</span><br><span class="line">    <span class="type">int</span> other;</span><br><span class="line">&#125;s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">Comp</span><span class="params">(constvoid*p1,constvoid*p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(*(Node*)p2).data&gt;(*（Node*）p1).data?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),Comp);</span><br></pre></td></tr></table></figure>
<ul>
<li>对结构体多级排序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;s[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//按照x从小到大排序，当x相等时按y从大到小排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Comp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*p1,<span class="type">const</span> <span class="type">void</span>*p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>*<span class="title">c</span>=</span>(Node*)p1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>*<span class="title">d</span>=</span>(Node*)p2;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;x!=d-&gt;x)returnc-&gt;x-d-&gt;x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> d-&gt;y-c-&gt;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对结构体的字符串</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">&#125;s[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//按照结构体中字符串str的字典序排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Comp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*p1,<span class="type">const</span> <span class="type">void</span>*p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>((*(Node*)p1).str,(*(Node*)p2).str);</span><br><span class="line">&#125;</span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),Comp);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法笔记</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法篇】排序——八大排序（c语言）</title>
    <url>/2022/02/15/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1>简介</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>1）比较相邻的元素。如果第一个比第二个大，就交换他们两个；<br>
2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；<br>
3）针对所有的元素重复以上的步骤，除了最后一个；<br>
4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h2 id="选择排序">选择排序</h2>
<p>1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；<br>
2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；<br>
3）重复第二步，直到所有元素均排序完毕。</p>
<h2 id="直接插入排序">直接插入排序</h2>
<p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>算法步骤：<br>
1）将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；<br>
2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置(相同则插入相等元素后边)。</p>
<h2 id="希尔排序-递减增量排序算法">希尔排序(递减增量排序算法)</h2>
<p>核心思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。<br>
1）选择一个增量序列d[1]，t[2]，…，d[k]，其中d[i]&gt;d[j]，d[k]=1；<br>
2）按增量序列个数k，对序列进行k 趟排序；<br>
3）每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h2 id="堆排序">堆排序</h2>
<p>利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序的平均时间复杂度为Ο(nlogn) 。</p>
<p>算法步骤：</p>
<p>1）创建一个堆H[0…n-1]</p>
<p>2）把堆首（最大值）和堆尾互换</p>
<p>3）把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</p>
<p>4） 重复步骤2，直到堆的尺寸为1</p>
<h2 id="快速排序">快速排序</h2>
<p>分而治之。通过排序将序列分割为两部分，左边都是比基线条件小的数，右边都是比它大的数；然后再按照这个方法对分割后的两个序列排序。</p>
<h2 id="归并排序">归并排序</h2>
<p>1）将需要排序的序列两两划分进行第一次组内排序；</p>
<p>2）将第一步排好的组再次两两组合进行组内排序；</p>
<p>3）重复以上步骤，直至最后一次排序完成；</p>
<h2 id="基数排序">基数排序</h2>
<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<h1>算法分析</h1>
<h2 id="1-算法排序的时间复杂度">1.算法排序的时间复杂度</h2>
<p>时间复杂度o(n^2)<br>
冒泡排序，选择排序，插入排序<br>
时间复杂度o(n*logn)<br>
归并排序，快速排序，堆排序，希尔排序<br>
时间复杂度o(n)<br>
基数排序</p>
<h2 id="2-算法排序的空间复杂度">2.算法排序的空间复杂度</h2>
<p>o(1)<br>
冒泡排序，选择排序，插入排序，堆排序，希尔排序<br>
o(nlogn)<br>
快速排序<br>
o(N)<br>
归并排序<br>
o(M)<br>
基数排序</p>
<h2 id="3-稳定性：相同值的元素排序前和排序后值保持不变">3.稳定性：相同值的元素排序前和排序后值保持不变</h2>
<p>稳定的排序算法：冒泡排序，插入排序，归并排序，基数排序；<br>
不稳定的排序算法：选择排序，快速排序，堆排序，希尔排序；</p>
<h2 id="4-不稳定原因">4.不稳定原因</h2>
<p>选择排序原因：在选择最小值和位置为0的数交换的时候产生；<br>
快速排序原因：在随机选择相同值中间的数的，两边的相同值的不不是被划分到选择值得左边就是选择值的右边；<br>
堆排序原因：在每次建立大根堆后，堆顶元素会换到最后的位置上去；<br>
希尔排序：步长为2时，第二个1跳两部，造成了不稳定；</p>
<h2 id="5-源码">5.源码</h2>
<p>详情见代码注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Create date:2019.10.8</span></span><br><span class="line"><span class="comment">Designer by:MaL</span></span><br><span class="line"><span class="comment">Compiling environment:Microsoft Visual Studio2012</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line"><span class="comment">// O(n^2)   O(1)    稳定 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				Swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择</span></span><br><span class="line"><span class="comment">// O(n^2)   O(1)    不稳定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">			&#123;</span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Swap(&amp;arr[i], &amp;arr[min]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序   数据越趋于有序，其效率越高</span></span><br><span class="line"><span class="comment">// O(n^2)     O(1)    稳定</span></span><br><span class="line"><span class="comment">//  最坏 O(n^2)   最好 O(n)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = arr[i];</span><br><span class="line">		<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; tmp)</span><br><span class="line">			&#123;</span><br><span class="line">				arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Shell2</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; d; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = d + k; i &lt; len; i += d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = arr[i];</span><br><span class="line">			<span class="type">int</span> j = i - d;</span><br><span class="line">			<span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= d)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; tmp)</span><br><span class="line">				&#123;</span><br><span class="line">					arr[j + d] = arr[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			arr[j + d] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Shell</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = arr[i];</span><br><span class="line">		<span class="type">int</span> j = i - d;</span><br><span class="line">		<span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; tmp)</span><br><span class="line">			&#123;</span><br><span class="line">				arr[j + d] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[j + d] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="comment">//  O(n ^1.3~1.5)   O(1)    不稳定  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 目前并没有一个合适的固定分组</span></span><br><span class="line">	<span class="comment">//  分组的值需要两两互质，并且最后一个分组必须为1</span></span><br><span class="line">	<span class="type">int</span> d[] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(d) / <span class="keyword">sizeof</span>(d[<span class="number">0</span>]); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Shell(arr, len, d[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  O(logn)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OneAdjust</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len, <span class="type">int</span> root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = root;</span><br><span class="line">	<span class="type">int</span> tmp = arr[i];</span><br><span class="line">	<span class="type">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//   left</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt; len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j + <span class="number">1</span> &lt; len &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			j = j + <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//  j 就是左右孩子中较大的哪一个</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			i = j;  <span class="comment">//  下一个子树的根</span></span><br><span class="line">			j = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//  下一个子树的左孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  O(nlogn) </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CreateHeap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> root = len / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; root &gt;= <span class="number">0</span>; --root)</span><br><span class="line">	&#123;</span><br><span class="line">		OneAdjust(arr, len, root);  <span class="comment">// O(logn)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//  O(nlogn)     O(1)      不稳定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	CreateHeap(arr, len);  <span class="comment">//  O(nlogn)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)  <span class="comment">// O(n)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Swap(&amp;arr[<span class="number">0</span>], &amp;arr[len - <span class="number">1</span> - i]);</span><br><span class="line"></span><br><span class="line">		OneAdjust(arr, len - i - <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//  O(logn)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="type">static</span>  <span class="type">int</span>  <span class="title function_">OneQuick</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> i,  <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = arr[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)   <span class="comment">//   保证找的整个过程  i  &lt; j</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j)   <span class="comment">//  从后向前找比tmp小的元素  保证  i &lt; j</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; tmp) <span class="keyword">break</span>;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[i] = arr[j];   <span class="comment">//   当找到比tmp小的元素后，将j位置的值存储到i位置</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j)  <span class="comment">//  从前向后找比tmp大的元素  保证  i &lt; j</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; tmp) <span class="keyword">break</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[j] = arr[i];  <span class="comment">//   当找到比tmp大的元素后，将i位置的值存储到j位置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[i] = tmp;   <span class="comment">//   i之前的数据都比tmp小， 之后的数据都比tmp大</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(nlogn)     O(logn)      不稳定</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Quick</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// O(n)</span></span><br><span class="line">	<span class="type">int</span> mod = OneQuick(arr, left, right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mod - left &gt; <span class="number">1</span>)   <span class="comment">//  i左边剩余的数据是否超过1个</span></span><br><span class="line">	&#123;</span><br><span class="line">		Quick(arr, left, mod - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (right - mod &gt; <span class="number">1</span>)  <span class="comment">// i右边剩余的数据是否超过1个</span></span><br><span class="line">	&#123;</span><br><span class="line">		Quick(arr, mod + <span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>  <span class="title function_">ForQuick</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack st;</span><br><span class="line">	<span class="type">int</span> size = (<span class="type">int</span>)(<span class="built_in">log10</span>((<span class="type">double</span>)(right - left + <span class="number">1</span>)) / <span class="built_in">log10</span>((<span class="type">double</span>)<span class="number">2</span>));</span><br><span class="line">	size = (size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>;</span><br><span class="line">	st.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">	assert(st.data != <span class="literal">NULL</span>);</span><br><span class="line">	st.top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	st.data[st.top++] = left;</span><br><span class="line">	st.data[st.top++] = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (st.top != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		right = st.data[--st.top];</span><br><span class="line">		left = st.data[--st.top];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> mod = OneQuick(arr, left, right);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mod - left &gt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.data[st.top++] = left;</span><br><span class="line">			st.data[st.top++] = mod - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (right - mod &gt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.data[st.top++] = mod + <span class="number">1</span>;</span><br><span class="line">			st.data[st.top++] = right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(st.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	ForQuick(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Meger</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len,  <span class="type">int</span> width, <span class="type">int</span> *brr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> L1 = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> H1 = L1 + width - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> L2 = H1 + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> H2 = L2 + width - <span class="number">1</span> &lt; len - <span class="number">1</span> ? L2 + width - <span class="number">1</span> : len - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (L1 &lt; len &amp;&amp; L2 &lt; len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (L1 &lt;= H1 &amp;&amp; L2 &lt;= H2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[L1] &lt; arr[L2])</span><br><span class="line">			&#123;</span><br><span class="line">				brr[num++] = arr[L1++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				brr[num++] = arr[L2++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (L1 &lt;= H1)</span><br><span class="line">		&#123;</span><br><span class="line">			brr[num++] = arr[L1++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (L2 &lt;= H2)</span><br><span class="line">		&#123;</span><br><span class="line">			brr[num++] = arr[L2++];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		L1 = H2 + <span class="number">1</span>;</span><br><span class="line">		H1 = L1 + width - <span class="number">1</span> &lt; len - <span class="number">1</span> ? L1 + width - <span class="number">1</span> : len - <span class="number">1</span>;</span><br><span class="line">		L2 = H1 + <span class="number">1</span>;</span><br><span class="line">		H2 = L2 + width - <span class="number">1</span> &lt; len - <span class="number">1</span> ? L2 + width - <span class="number">1</span> : len - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (L1 &lt;= H1)</span><br><span class="line">	&#123;</span><br><span class="line">		brr[num++] = arr[L1++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = brr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">// O(nlogn)    O(n)     稳定</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MegerSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *brr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Meger(arr, len, i, brr);   <span class="comment">// O(n)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(brr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  求数组中最大数字的宽度</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>  <span class="title function_">GetMaxWidth</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; max)  max = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (max)  <span class="comment">//  12</span></span><br><span class="line">	&#123;</span><br><span class="line">		width++;</span><br><span class="line">		max /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  求data的倒数第i+1位上的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GetNumOfWidth</span><span class="params">(<span class="type">int</span> data, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (i)</span><br><span class="line">	&#123;</span><br><span class="line">		data /= <span class="number">10</span>;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(d * n)      O(k + n)     稳定</span></span><br><span class="line"><span class="comment">// 基数排序      不需要比较的排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RadixSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	    1、创建队列</span></span><br><span class="line"><span class="comment">		2、先求最大数字的位数</span></span><br><span class="line"><span class="comment">		3、求出相应位数的值， 并根据位数值将其存储相应的队列中</span></span><br><span class="line"><span class="comment">		4、按顺序输出所有队列中的值，  循环处理3,4步，循环次数由第一步算出</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	Que que[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		que[i].data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* len);</span><br><span class="line">		assert(que[i].data != <span class="literal">NULL</span>);</span><br><span class="line">		que[i].head = que[i].tail = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> width = GetMaxWidth(arr, len); <span class="comment">// O(n)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; width; ++i)  <span class="comment">// O(d * n)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//  将数组中所有的数字取其相应位数的值，并将其存储到相应的队列中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  num = GetNumOfWidth(arr[j], i);</span><br><span class="line">			que[num].data[que[num].tail++] = arr[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">10</span>; ++m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (que[m].head != que[m].tail)</span><br><span class="line">			&#123;</span><br><span class="line">				arr[k++] = que[m].data[que[m].head++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">		&#123;</span><br><span class="line">			que[n].head = que[n].tail = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(que[i].data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法笔记</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>关于出栈序列的解法总结及卡特兰数的学习（C语言）</title>
    <url>/2022/02/15/%E5%85%B3%E4%BA%8E%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%E7%9A%84%E8%A7%A3%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88C%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>出栈次序</h1>
<blockquote>
<p>一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?</p>
</blockquote>
<h2 id="解法1——递归-记忆化搜索">解法1——递归/记忆化搜索</h2>
<ol>
<li>考虑用一个二维数组f[i][j]模拟当前情况：i——进栈序列中还有i个待排的数，j——栈中有j个数，f[i][j]的<strong>值</strong>表示当前i,j情况下有几种输出方案。</li>
<li>首先如果f[i][j]有值，直接调用即可（记忆化搜索，节省时间）；</li>
<li>如果i=0，即序列全部入栈，只有一种输出方法，所以返回1；</li>
<li>考虑一般情况，有两种输出方案，先进一个再出，即加上f[i-1][j+1],（栈不空时,j&gt;0,如果栈空只有第一种输出方案可行）直接出，即加上f[i][j-1]。</li>
</ol>
<p><em>代码如下</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAX][MAX];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i][j])</span><br><span class="line">		<span class="keyword">return</span> f[i][j];</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">		f[i][j] += dfs(i, j - <span class="number">1</span>);</span><br><span class="line">	f[i][j] += dfs(i - <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> f[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, dfs(n, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法2——递推">解法2——递推</h2>
<ol>
<li>首先重设一下f[i][j],f的含义不变，i为入栈数，j为出栈数；</li>
<li>我们知道f[0][j]=1，因为序列全部入栈，出栈次序是唯一的。</li>
<li>然后我们来考虑一下递归关系，如何得到f[i][j]?即怎么得到i个数入栈，j个数出栈的情况，只需要有i-1个数入栈，出栈j个，此时再入栈一个就是f[i][j]；同理，可以是i个数入栈，j-1个出栈。所以我们得到递归关系f[i][j]=f[i-1][j]+f[i][j-1]。</li>
<li>但涉及到出栈必须考虑栈空的情况，什么时候栈空？<strong>i=j</strong>时，就只有f[i][j]=f[i-1][j]。</li>
</ol>
<p><em>递归做法</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAX_N][MAX_N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">else</span> f[i][j]=f[i][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法3——卡特兰数">解法3——卡特兰数</h2>
<p>关于卡特兰数列的详细解释移步<a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin">百度百科</a></p>
<ul>
<li>我们可以直接用的是它的四个递推公式</li>
</ul>
<blockquote>
<p>设h(n)为catalan数的第n项，令h(0)=1,h(1)=1，catalan数满足递推式 ：<br>
1)h(n)= h(0)*h(n-1)+h(1)*h(n-2) + … + h(n-1)<em>h(0) (n≥2)<br>
2)h(n)=h(n-1) * (4</em>n-2)/(n+1)<br>
3)h(n)=C(2n,n)/(n+1) (n=0,1,2,…)<br>
4)h(n)=C(2n,n) - C(2n,n-1) (n=0,1,2,…)</p>
</blockquote>
<p><em>代码</em><br>
<em><s>都有递推关系了代码不是有手就行</s></em></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//给出公式4作为参照</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[MAX][MAX];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,c[<span class="number">2</span>*n][n]-c[<span class="number">2</span>*n][n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键是分析为什么可以用卡特兰"><strong>关键</strong>是分析为什么可以用卡特兰</h3>
<ul>
<li><strong>原理分析</strong>：</li>
<li>建立数组f。f[i]表示i个数的全部可能性。<br>
f[0] = 1, f[1] = 1; //当然只有一个<br>
设 x 为当前出栈序列的最后一个，则x有n种取值<br>
由于x是最后一个出栈的，所以可以将已经出栈的数分成两部分<br>
1.比x小<br>
2.比x大<br>
比x小的数有x-1个，所以这些数的全部出栈可能为f[x-1]<br>
比x大的数有n-x个，所以这些数的全部出栈可能为f[n-x]<br>
这两部分互相独立，所以根据乘法原理，一个x的取值能够得到的所有可能性为f[x-1] * f[n-x]<br>
另外，由于x有n个取值，所以<br>
ans = f[0]*f[n-1] + f[1]*f[n-2] + … + f[n-1]*f[0];</li>
<li><strong>或者这样分析</strong>：</li>
<li>我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。<br>
那么合法序列就是总序列-非法序列，总序列(由n次出栈n次入栈操作构成的序列数)为C(2n,n)。<br>
<strong>非法序列</strong>：由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，<strong>结果得1个由n+1个0和n-1个1组成的2n位数</strong>，即<strong>一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列</strong>。反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即<strong>n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数</strong>。<br>
这就证明了<strong>不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。</strong>，为C(2n,n+1)<br>
所以有<strong>输出序列的总数目=c(2n,n)-c(2n,n-1)=c(2n,n)/(n+1)=h(n)。</strong></li>
</ul>
<p>我觉得这类题目可以总结为==由特定顺序（二者匹配）的两种状态组成的排序数==类问题</p>
<h3 id="类似题目有">类似题目有</h3>
<blockquote>
<p><strong>括号序列</strong>  ：n 对括号，则有多少种 “括号匹配” 的括号序列</p>
</blockquote>
<p>——左括号看作1，右括号看作0，和上题一样</p>
<blockquote>
<p><strong>二叉树</strong>n + 1 个叶子节点能够构成多少种形状不同的（国际）满二叉树<br>
（国际）满二叉树定义：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p>
</blockquote>
<p>——形成满二叉树需要先向左扩展，再向右扩展，左右匹配，所以向左看作1，向右看作0，n+1个叶子结点有2n次扩展，还原为出入栈</p>
<blockquote>
<p><strong>买票找零</strong>：有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少种方法使得只要有10元的人买票，售票处就有5元的钞票找零</p>
</blockquote>
<p>——拿5元的看作1，10元的看作0</p>
<p><s>所以要对这类题目有一定敏感性</s></p>
<h3 id="有关题目练习可以去：">有关题目练习可以去：</h3>
<p><a href="https://www.luogu.com.cn/problem/P1044">栈</a><br>
<a href="https://www.luogu.com.cn/problem/P1754">球迷购票问题</a><br>
<a href="https://www.luogu.com.cn/problem/P1754">鸡蛋饼</a></p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建XuperChain链过程</title>
    <url>/2022/02/14/%E6%90%AD%E5%BB%BAXuperChain%E9%93%BE%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://github.com/xuperchain/xuperchain#xuperchain%E6%98%AF%E4%BB%80%E4%B9%88">参考文档</a></p>
<h2 id="环境准备">环境准备</h2>
<ul>
<li>虚拟机Ubuntu</li>
<li>配置git<br>
<code>sudo apt install git</code></li>
<li>配置golang<br>
<code>sudo apt install golang-go</code><br>
检查go的环境是否配置完成可用命令<br>
<code>go version</code><br>
若出现如此标识表示成功配置<br>
<img src="https://img-blog.csdnimg.cn/b46a91244b054654bd5eefbcd9f5f146.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h2 id="编译XuperChain">编译XuperChain</h2>
<ul>
<li>
<p>使用git下载源码到本地<br>
<code>git clone https://github.com/xuperchain/xuperchain.git</code></p>
</li>
<li>
<p>编译<br>
<code>cd xuperchain (总之进入xuperchain这个目录）</code><br>
直接make可能会连接失败 像这样被拒绝访问<br>
<img src="https://img-blog.csdnimg.cn/10890c447b2840aa9e6f7f44ea4d0ab4.png#pic_center" alt="在这里插入图片描述"><br>
所以先执行<br>
<code>go env -w GOPROXY=https://goproxy.cn</code><br>
更改权限<br>
<code>su chmod 777 xuperchain路径</code><br>
再<br>
<code>make</code><br>
编译顺利进行<br>
<img src="https://img-blog.csdnimg.cn/47117a65baae4a36a4fc8effae3bd123.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57Sr54KB,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
</li>
<li>
<p>跑单测测试<br>
<code>make test</code><br>
<img src="https://img-blog.csdnimg.cn/d9cdf877a54e42409dee4ce0d715e649.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57Sr54KB,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
==上述命令均在xuperchain目录下进行==</p>
</li>
<li>
<p>构建单节点xchain<br>
<code>cd ./output (进入output文件）</code><br>
直接执行脚本会报错<br>
<img src="https://img-blog.csdnimg.cn/2b1323f37e6448fc85b33ed023310c09.png#pic_center" alt="在这里插入图片描述"><br>
需要先执行<br>
<code>sudo dpkg-reconfigure dash</code><br>
然后依次执行<br>
<code>sh ./control.sh start</code><br>
<code>./bin/xchain-cli status</code><br>
生成这样的就成功构建了<br>
<img src="https://img-blog.csdnimg.cn/99810a38fafe494ca69ae599b71ca73e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA57Sr54KB,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
</li>
<li>
<p>构建多节点<br>
首先<br>
<code>cd ..</code>将目录切回上级的xuperchain<br>
然后再<br>
<code>make testnet</code><br>
此后顺次执行文档中的命令即可</p>
</li>
</ul>
]]></content>
      <categories>
        <category>环境配置</category>
        <category>XuperChain</category>
      </categories>
      <tags>
        <tag>XuperChain</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构篇】链表</title>
    <url>/2022/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91%E9%93%BE%E8%A1%A8%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>【数据结构篇】链表</h1>
<h2 id="设计链表">设计链表</h2>
<ul>
<li>在链表类中实现这些功能：</li>
</ul>
<blockquote>
<p>·get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>
·addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>
·addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>
·addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>
·deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
</blockquote>
<ul>
<li><em>代码示例如下</em></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">MyLinkedList *<span class="title function_">myLinkedListCreate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	MyLinkedList *obj = (MyLinkedList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">	obj-&gt;val = <span class="number">0</span>;</span><br><span class="line">	obj-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">myLinkedListGet</span><span class="params">(MyLinkedList *obj, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || obj-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">	MyLinkedList *listNow = obj-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (now &lt; index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (listNow == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		listNow = listNow-&gt;next;</span><br><span class="line">		now++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (listNow != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> listNow-&gt;val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtHead</span><span class="params">(MyLinkedList *obj, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyLinkedList *Node = (MyLinkedList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">	Node-&gt;val = val;</span><br><span class="line">	Node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (obj-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		obj-&gt;next = Node;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node-&gt;next = obj-&gt;next;</span><br><span class="line">		obj-&gt;next = Node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtTail</span><span class="params">(MyLinkedList *obj, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyLinkedList *Node = (MyLinkedList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">	Node-&gt;val = val;</span><br><span class="line">	Node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	MyLinkedList *nowList = obj;</span><br><span class="line">	<span class="keyword">while</span> (nowList-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		nowList = nowList-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nowList-&gt;next = Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtIndex</span><span class="params">(MyLinkedList *obj, <span class="type">int</span> index, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		myLinkedListAddAtHead(obj, val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">	MyLinkedList *nowList = obj-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (nowList-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (now == index - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nowList = nowList-&gt;next;</span><br><span class="line">		now++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index - <span class="number">1</span> != now)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MyLinkedList *Node = (MyLinkedList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">	Node-&gt;val = val;</span><br><span class="line">	Node-&gt;next = nowList-&gt;next;</span><br><span class="line">	nowList-&gt;next = Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListDeleteAtIndex</span><span class="params">(MyLinkedList *obj, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyLinkedList *r;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || obj-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r = obj-&gt;next;</span><br><span class="line">		obj-&gt;next = obj-&gt;next-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(r);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MyLinkedList *nowList = obj-&gt;next;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (nowList-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (now == index - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nowList = nowList-&gt;next;</span><br><span class="line">		now++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (now == index - <span class="number">1</span> &amp;&amp; nowList-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r = nowList-&gt;next;</span><br><span class="line">		nowList-&gt;next = nowList-&gt;next-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myNodeFree</span><span class="params">(MyLinkedList *Node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Node-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    myNodeFree(Node-&gt;next);</span><br><span class="line">    Node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(Node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListFree</span><span class="params">(MyLinkedList *obj)</span></span><br><span class="line">&#123;<span class="comment">//从最后一个结点向前逐渐释放，这里用递归实现</span></span><br><span class="line">    myNodeFree(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环形链表">环形链表</h2>
<ul>
<li>可以用<strong>快慢指针</strong>判断是否有环（有环返回真，无环返回假）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  &#125;ListNode;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *f=head;</span><br><span class="line">        ListNode *s=head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(f-&gt;next==<span class="literal">NULL</span>||f-&gt;next-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            f=f-&gt;next-&gt;next;<span class="comment">//f为走两步的快指针</span></span><br><span class="line">            s=s-&gt;next;<span class="comment">//s为走一步的慢指针</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(f!=s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果有环一定能相遇</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>如果要返回==入环的第一个结点==呢？</em></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210613191744346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NreWVfcg==,size_16,color_FFFFFF,t_70#pic_center" alt="示例"><br>
可以这样分析：<br>
1 慢指针走过的路程为a(头结点到环入口的距离)+b(慢指针在环内的距离)<br>
2 快指针走过的路程为a+b+c(相遇点到换入口的距离)+b<br>
3 因为快指针速度是慢指针的两倍，所以可以导出a=c<br>
4 所以只要再安排一个位于头结点的指针和慢指针同时出发，它们的相遇位置即为环入口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">f</span>=</span>head;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">s</span>=</span>head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(f-&gt;next==<span class="literal">NULL</span>||f-&gt;next-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            f=f-&gt;next-&gt;next;<span class="comment">//f为走两步的快指针</span></span><br><span class="line">            s=s-&gt;next;<span class="comment">//s为走一步的慢指针</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(f!=s);</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">p</span>=</span>head;</span><br><span class="line">       <span class="keyword">while</span>(p!=s)</span><br><span class="line">       &#123;</span><br><span class="line">           p=p-&gt;next;</span><br><span class="line">           s=s-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回文链表">回文链表</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nextTemp</span> =</span> curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;<span class="comment">//反转链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">endOfFirstHalf</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">firstHalfEnd</span> =</span> endOfFirstHalf(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">secondHalfStart</span> =</span> reverseList(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否回文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p1</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p2</span> =</span> secondHalfStart;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">    firstHalfEnd-&gt;next = reverseList(secondHalfStart);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><s>持续更新中</s></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构篇】树的遍历</title>
    <url>/2022/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91%E6%A0%91%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>树的遍历</h1>
<h2 id="前序遍历">前序遍历</h2>
<ul>
<li>
<p>首先访问根节点，然后遍历左子树，最后遍历右子树</p>
<p><em>递归写法</em></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preTravel</span><span class="params">(<span class="keyword">struct</span> TreeNode*root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,root-&gt;val);</span><br><span class="line">        travel(root-&gt;left);</span><br><span class="line">        travel(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>迭代写法 (迭代就是把递归过程中调用的栈显式表达出来)</em></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preTravel</span><span class="params">(<span class="keyword">struct</span> TreeNode*root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stk</span>[100];</span></span><br><span class="line">    <span class="type">int</span> stk_top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stk_top &gt; <span class="number">-1</span> || root != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,root-&gt;val);</span><br><span class="line">            stk[++stk_top] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[stk_top--];</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="中序遍历">中序遍历</h2>
<ul>
<li>
<p>先左后根最后右（==二叉搜索树中可以得到递增的有序序列==）</p>
<p><em>递归写法</em></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inorderTravel</span><span class="params">(<span class="keyword">struct</span> TreeNode*root)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorderTravel(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,root-&gt;val);</span><br><span class="line">    inorderTravel(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>迭代写法 (迭代就是把递归过程中调用的栈显式表达出来)</em></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inorderTravel</span><span class="params">(<span class="keyword">struct</span> TreeNode*root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stk</span>[100];</span></span><br><span class="line">    <span class="type">int</span> stk_top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stk_top &gt; <span class="number">-1</span> || root != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            stk[++stk_top] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[stk_top--];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="后序遍历">后序遍历</h2>
<ul>
<li>
<p>先左后右最后根</p>
<p><em>递归写法</em></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">postTravel</span><span class="params">(<span class="keyword">struct</span> TreeNode*root)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postTravel(root-&gt;left,a,returnSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,root-&gt;val);</span><br><span class="line">    postTravel(root-&gt;right,a,returnSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>迭代写法</em></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preTravel</span><span class="params">(<span class="keyword">struct</span> TreeNode*root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stk</span>[100];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> stk_top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (stk_top &gt; <span class="number">-1</span> || root != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            stk[++stk_top] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root=stk[stk_top--];</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span> || root-&gt;right == prev) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,root-&gt;val);</span><br><span class="line">            prev = root;</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            stk[top++] = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="层序遍历">层序遍历</h2>
<ul>
<li>用队列实现广度优先搜索，逐层遍历</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 2000</span></span><br><span class="line"><span class="type">int</span> **<span class="title function_">levelOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode*root,<span class="type">int</span> *returnSize,<span class="type">int</span> **returnColumnSize)</span></span><br><span class="line">&#123;<span class="comment">//返回逐层遍历的二维数组，returnColumnSize记录每一层的大小</span></span><br><span class="line">    *returnSize=<span class="number">0</span>;<span class="comment">//层数</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span>**res=(<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*MAX);<span class="comment">//申请一个二维数组空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>*<span class="title">Q</span>[<span class="title">MAX</span>];</span><span class="comment">//队，存放所有结点</span></span><br><span class="line">    *returnColumnSize=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*MAX);</span><br><span class="line">    <span class="type">int</span> flag,size,front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>*<span class="title">tmp</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    Q[rear++]=root;</span><br><span class="line">    <span class="keyword">while</span>(front!=rear)</span><br><span class="line">    &#123;<span class="comment">//队列不空时</span></span><br><span class="line">        flag=rear;<span class="comment">//当前层尾指针</span></span><br><span class="line">        size=<span class="number">0</span>;<span class="comment">//当前层数组大小</span></span><br><span class="line">        res[*returnSize]=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*(flag-front));</span><br><span class="line">        <span class="keyword">while</span>(front&lt;flag)</span><br><span class="line">        &#123;<span class="comment">//处理当前层</span></span><br><span class="line">            tmp=Q[front++];</span><br><span class="line">            res[*returnSize][size++]=tmp-&gt;val;</span><br><span class="line">            <span class="comment">//每个结点的左右孩子入队</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                Q[rear++]=p-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                Q[rear++]=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        (*returnColumnSize)[*returnSize]=size;</span><br><span class="line">        returnSize++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归解决问题">递归解决问题</h2>
<ul>
<li>最大深度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span> :fmax(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对称二叉树</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isMirror</span><span class="params">(<span class="keyword">struct</span> TreeNode*p,<span class="keyword">struct</span> TreeNode*q)</span></span><br><span class="line">&#123;<span class="comment">//递归思想：如果对称，那每个树的右子树镜像对称另一个树的左子树</span></span><br><span class="line">    <span class="keyword">if</span>(!p&amp;&amp;!q)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p||!q)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (p-&gt;val==q-&gt;val)&amp;&amp;(isMirror(p-&gt;left,q-&gt;right))&amp;&amp;(isMirror(p-&gt;right,q-&gt;left));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root,root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>路径总和</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断二叉树中是否有一条路径节点之和等于目标值</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val==targetSum;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left,targetSum-root-&gt;val)||hasPathSum(root-&gt;right,targetSum-root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最近公共祖先</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">lowestCommonAncestor</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">ancestor</span>=</span>root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val&lt;ancestor-&gt;val&amp;&amp;q-&gt;val&lt;ancestor-&gt;val)</span><br><span class="line">            ancestor=ancestor-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val&gt;ancestor-&gt;val&amp;&amp;q-&gt;val&gt;ancestor-&gt;val)</span><br><span class="line">            ancestor=ancestor-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最长路径</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N] , ne[N] , h[N] , idx;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//f[u]表示u到最远叶节点的距离。显然如果u是节点，则f[u]=0。</span></span><br><span class="line"><span class="type">int</span> n , m , ans;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b , ne[idx] = h[a] , h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//求以u为根节点到叶节点的最大距离</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span> , b = <span class="number">0</span>;<span class="comment">//a记录u到最远叶节点的距离，b记录u到次远叶节点的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u] ; ~i ; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//求子节点j到最远叶节点的距离</span></span><br><span class="line">        dfs(j);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = f[j] + <span class="number">1</span>;<span class="comment">//u通过j能到的最远叶节点的距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新a、b</span></span><br><span class="line">        <span class="keyword">if</span>(t &gt;= a)</span><br><span class="line">            b = a , a = t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; b)</span><br><span class="line">            b = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[u] = a;</span><br><span class="line">    <span class="comment">//最后的答案就是u所能到的最远叶节点距离和次远叶节点距离之和</span></span><br><span class="line">    ans = max(ans , a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h , <span class="number">-1</span> , <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//电脑其实和交换机等价，所以电脑的标号从n继续往后标记即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> ; i &lt;= n + m ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line">        add(j , i);<span class="comment">//因为是自根向下DP，所以建一条边即可。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
</search>
