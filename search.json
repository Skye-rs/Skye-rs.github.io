[{"title":"DeelMind小白网安入门","url":"/CTF/DeelMind%E5%B0%8F%E7%99%BD%E7%BD%91%E5%AE%89%E5%85%A5%E9%97%A8.html","content":"HTML潜在漏洞\n\n纯HTML基本没有漏洞\nIframe clickjack\n\nCSS和潜在漏洞\n\n纯CSS漏洞很少\nhttps://github.com/maxchehab/CSS-Keylogging\n\nJavascript\n&lt;学会Javascript&gt;\nPHP\n&lt;学会PHP&gt;\nSQL注入详解和简单绕过原理\n&lt;学会数据库&gt;\n","categories":["CTF"],"tags":["Web安全"]},{"title":"Kali更新步骤","url":"/CTF/Kali%E6%9B%B4%E6%96%B0.html","content":"更改更新源（用哪个把其他注释掉）\nvi /etc/apt/sources.list\n使用vim，按i插入，复制源粘贴，按Esc，输入:q保存并退出，（需在root模式下进行su root)\n#中科大kali源deb http://mirrors.ustc.edu.cn/kali kali main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali main non-free contribdeb http://mirrors.ustc.edu.cn/kali-security kali/updates main contrib non-free#新加坡kali源deb http://mirror.nus.edu.sg/kali/kali/ kali main non-free contribdeb-src http://mirror.nus.edu.sg/kali/kali/ kali main non-free contribdeb http://security.kali.org/kali-security kali/updates main contrib non-freedeb http://mirror.nus.edu.sg/kali/kali-security kali/updates main contrib non-freedeb-src http://mirror.nus.edu.sg/kali/kali-security kali/updates main contrib non-free#阿里云kali源deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#163 Kali源deb http://mirrors.163.com/debian wheezy main non-free contribdeb-src http://mirrors.163.com/debian wheezy main non-free contribdeb http://mirrors.163.com/debian wheezy-proposed-updates main non-free contribdeb-src http://mirrors.163.com/debian wheezy-proposed-updates main non-free contribdeb-src http://mirrors.163.com/debian-security wheezy/updates main non-free contribdeb http://mirrors.163.com/debian-security wheezy/updates main non-free contrib#autodeb http://http.kali.org/kali kali-rolling main non-free contrib#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#浙大deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free#东软大学deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contribdeb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib#重庆大学deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib#官方源#deb http://http.kali.org/kali kali-rolling main non-free contrib#deb-src http://http.kali.org/kali kali-rolling main non-free contrib\n依次执行下述命令更新：\napt-get update          //执行命令更新源apt-get upgrade          //更新所有软件apt-get upgrade hydra        //更新指定软件，hydra可以为任意软件名apt-get dist-upgrade //软件升级并安装apt-get clean       //清理reboot            //重启\n","categories":["CTF"],"tags":["kali"]},{"title":"CTF-web-信息泄露","url":"/CTF/web-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2.html","content":"Git泄露\n当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。\nlog\n利用工具-GitHack\ngit clone git://github.com/BugScanTeam/GitHack.git\n进入GitHck文件夹，使用python2\npython2 GitHack.py http://challenge-c1bea46c13604f27.sandbox.ctfhub.com:10800/.git/\n还原后的文件在dist/目录下，进入\ncd  \\dist\\challenge-55b6c65232b6b6ab.sandbox.ctfhub.com_10080\\\n在这里检查git提交历史记录log，git log查看日志,可以看到add flag后又remove，所以检查当前版本与上一个版本的区别git diff 版本号\n\n找到flag\nStash\n\n\ngit stash用于保存本地修改，将代码切换到head提交上\n\n\n用githack扫描网址，进入产生的文件夹中，依次执行\n  git stash list //查看当前存储git stash pop //恢复之前的工作目录cat 147902533125205.txt//获得txt文件//得到flag\n\n\n","categories":["CTF","web"],"tags":["Web安全"]},{"title":"信号与系统第二次实验","url":"/MATLAB%E4%BF%A1%E5%8F%B7%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/20373540_%E9%99%88%E6%98%A5%E8%95%8A_%E4%BF%A1%E5%8F%B7%E7%AC%AC2%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html","content":"实验内容\n题目一\n系统输入为𝑥(𝑡)=𝑒−𝑡cos(3𝑡)(𝑢(𝑡)−𝑢(𝑡−2))𝑥(𝑡) = 𝑒 ^{−𝑡} cos(3𝑡) (𝑢(𝑡) − 𝑢(𝑡 − 2))x(t)=e−tcos(3t)(u(t)−u(t−2))，其冲激响应ℎ(𝑡) = 𝑡−1𝑡 ^{−1}t−1 (𝑢(𝑡 − 1) − 𝑢(𝑡 − 3))，计算其输出𝑦(𝑡) = 𝑥(𝑡) ∗ℎ(𝑡) （可调用函数 conv）。在多张子图上绘制𝑥(𝑡)、ℎ(𝑡)及𝑦(𝑡)的图像， 绘图区间均为[-1, 6]；要求有坐标轴标注（xlabel,ylabel）以及图题 （title）\n踩坑点\n最开始十分直接的写完x(t)和h(t)求卷积就画图了，直接报错，经一番排查发现需要注意两点：\n\n\n虽然ℎ(𝑡) = 𝑡−1𝑡 ^{−1}t−1 (𝑢(𝑡 − 1) − 𝑢(𝑡 − 3)),但若直接写为h=(Heaviside(t-1)-Heaviside(t-3))./t;MatLab计算过程1中会出现NaN，这是由于在t=0t=0t=0处，h(t)h(t)h(t)出现了0/00/00/0不定型,但实际可以用洛必达法则求得h(0)=0h(0)=0h(0)=0,故将分母加一个小量修正为h=(Heaviside(t-1)-Heaviside(t-3))./(t+eps)\n\n\n求卷积后坐标范围会发生变化,求得的y(t)y(t)y(t)与ttt本身的坐标范围并不一一对应,实际上假设对x(k)x(k)x(k)和h(k)h(k)h(k)做卷积,x(k)x(k)x(k)的区间范围为n1:n2n_1:n_2n1​:n2​,h(k)h(k)h(k)的区间范围为m1:m2m_1:m_2m1​:m2​,模拟卷积步骤 翻转 移位 相乘 累加,如图h(−k)h(-k)h(−k)左移的极限长度是−m1−n1-m_1-n_1−m1​−n1​,故y(k)=x(k)∗h(k)y(k)=x(k)∗h(k)y(k)=x(k)∗h(k)的左侧起点为m1+n1m_1+n_1m1​+n1​,同理得右侧终点为m2+n2m_2+n_2m2​+n2​,整个序列长为m2+n2−m1−n1+1=len(x(k))+len(h(k))−1m_2+n_2-m_1-n_1+1=len(x(k))+len(h(k))-1m2​+n2​−m1​−n1​+1=len(x(k))+len(h(k))−1.\n在本题中y(t)y(t)y(t)的坐标范围就是[−2,12][-2,12][−2,12],需要在新坐标上作图再截取[−1,6][-1,6][−1,6]范围,否则会出错.\n\n\n\n调用conv计算卷积时需要*dt,因为conv(u,v)返回向量u,v的卷积,而连续信号的卷积定义为u(k)∗v(k)=∫−∞+∞u(t)v(k−t)dtu(k)\\ast v(k)=\\int_{-\\infty}^{+\\infty}u(t)v(k-t)dtu(k)∗v(k)=∫−∞+∞​u(t)v(k−t)dt,需要乘以微量dtdtdt\n\n\n代码\nclear all;ts=-1;te=6;dt=0.01; t=ts:dt:te; x=exp(-1*t).*cos(3*t).*(Heaviside(t)-Heaviside(t-2));h=(Heaviside(t-1)-Heaviside(t-3))./(t+eps);y=conv(x,h)*dt;%disp(y);ty=-2:dt:12;subplot(3,1,1);plot(t,x);grid;xlabel(&#x27;t&#x27;);ylabel(&#x27;x(t)&#x27;);title(&#x27;输入信号x(t)的波形&#x27;);subplot(3,1,2);plot(t, h);grid;xlabel(&#x27;t&#x27;);ylabel(&#x27;h(t)&#x27;);title(&#x27;冲激响应h(t)的波形&#x27;);subplot(3,1,3);plot(ty,y);grid;axis([-1,6,-0.5,0.5]) xlabel(&#x27;t&#x27;);ylabel(&#x27;y(t)&#x27;);title(&#x27;系统输出y(t)的波形&#x27;);\n仿真图\n题目二\n对离散时间线性时不变系统 𝑦[𝑛] = 𝑥[𝑛] ∗ h[𝑛] ， 有 h[𝑛] = 2 −𝑛(𝑢[𝑛] − 𝑢[𝑛 − 6])，当该系统的输入𝑥[𝑛] = 𝑒 −0.05𝑛 (𝑢[𝑛 + 8] − 𝑢[𝑛 − 4])时，计算该系统的输出𝑦[𝑛]；要求在多张子图上绘制 𝑥[𝑛]、h[𝑛]及𝑦[𝑛]的图像（使用 subplot），绘图区间均为[-10, 10]， 要求有坐标轴标注及图题。提示：使用 stem 函数。\n整体做法与题一相似，对应地换为离散信号即可。\n代码\nclear all;ns=-10;ne=10;dn=1; n=ns:dn:ne; x=exp(-0.05*n).*(jyxl(n+8)-jyxl(n-4));h=(jyxl(n)-jyxl(n-6))./(2.^n);y=conv(x,h);%disp(y);ny=-20:dn:20;subplot(3,1,1);stem(n,x);grid;xlabel(&#x27;n&#x27;);ylabel(&#x27;x(n)&#x27;);title(&#x27;输入信号x(n)&#x27;);subplot(3,1,2);stem(n, h);grid;xlabel(&#x27;n&#x27;);ylabel(&#x27;h(n)&#x27;);title(&#x27;冲激响应h(n)&#x27;);subplot(3,1,3);stem(ny,y);grid;axis([-10,10,-5,5]) xlabel(&#x27;n&#x27;);ylabel(&#x27;y(n)&#x27;);title(&#x27;系统输出y(n)&#x27;);\n仿真图\n\n题目三\n线性时不变系统的微分方程为：𝑦’(𝑡) + 2𝑦(𝑡) = 𝑥(𝑡)，求其冲激以及阶跃响应，并在同一张图上绘图（使用 hold on），横坐标区间为 [0, 5]，要求有坐标轴标注、图题以及图例（legend）。提示：可分 别使用 impulse 与 step 函数求解\n分别调用impulse()和step()函数求解冲激响应和阶跃响应。\n代码\nclear all; ts=0;te=5;dt=0.01; num=[1]; den=[1 2]; sys=tf(num,den); t=ts:dt:te; y=impulse(sys,t); %求解冲激响应的函数plot(t,y,&#x27;r&#x27;);grid; xlabel(&#x27;time(sec)&#x27;);hold on;step(num,den,&#x27;b&#x27;);grid;legend(&#x27;冲激响应&#x27;, &#x27;阶跃响应&#x27;)title(&#x27;系统的冲激及阶跃响应&#x27;)axis([0,5,0,1])\n仿真图\n\n题目四\n因 果 线 性 时 不 变 系 统 的 微 分 方 程 为 𝑦’’(𝑡) + 𝑦’(𝑡) + 2𝑦(𝑡) = 𝑥’(𝑡) + 2𝑥(𝑡)，输入为𝑥(𝑡) = (𝑒 −𝑡 + 𝑒 −2𝑡 )𝑢(𝑡)。请分别使用冲激响应卷积法以及调用 lism 函数的方法求解并画出系统对𝑥(𝑡)的零状态响应（在多张子图上绘制）；要求有坐标轴标注以及图题。横坐 标区间自定，使结果清晰即可。\n\n零输入响应——无输入下的系统响应，即某一状态下的响应\n零状态响应——认为没有初始状态，系统对于外界输入的响应，求解即解微分方程\n\n系统的零状态响应=激励与系统冲激响应的卷积，r(t)=x(t)∗h(t)r(t)=x(t)\\ast h(t)r(t)=x(t)∗h(t),使用residue()函数求得冲激h(t)h(t)h(t)后再做卷积即可。\n代码\nclear all; ts=0;te=15;dt=0.01; num=[0 1 2]; den=[1 1 2]; sys=tf(num,den); % 调用 LTI 系统模型的函数t=ts:dt:te; f=(exp(-1*t )+exp(-2*t)).*Heaviside(t);y=lsim(sys,f,t); % 求零初始条件微分方程数值解subplot(2,1,1);plot(t,y); xlabel(&#x27;t(sec)&#x27;);ylabel(&#x27;y(t)&#x27;);grid;title(&#x27;lism函数法求零状态响应&#x27;);subplot(2,1,2);%冲激响应卷积法[r,p,k]=residue(num,den); %分式的留数？极点、直项？ 大概就是化简分式的意思h=r(1)*exp(p(1)*t)+r(2)*exp(p(2)*t);g=conv(f,h)*dt;x=0:dt:30;plot(x,g);grid;axis([0,15,-0.5,1.5]);xlabel(&#x27;x(sec)&#x27;);ylabel(&#x27;g(x)&#x27;);title(&#x27;冲激响应卷积法求零状态响应&#x27;);\n仿真图\n\n思考题\n\n连续、离散信号卷积的定义？卷积的作用是？\n\n连续信号卷积定义为\n(f1∗f2)(t):=f1(t)∗f2(t):=∫−∞+∞f1(τ)f2(t−τ)dτ:=∫−∞+∞f1(t−τ)f2(τ)dτ\\left(f_1 * f_2\\right)(t):=f_1(t) * f_2(t):=\\int_{-\\infty}^{+\\infty} f_1(\\tau) f_2(t-\\tau) d \\tau:=\\int_{-\\infty}^{+\\infty} f_1(t-\\tau) f_2(\\tau) d \\tau\n(f1​∗f2​)(t):=f1​(t)∗f2​(t):=∫−∞+∞​f1​(τ)f2​(t−τ)dτ:=∫−∞+∞​f1​(t−τ)f2​(τ)dτ\n离散信号卷积定义为\n(f∗g)[n]=∑m=−∞∞f[m]g[n−m]=∑m=−∞∞f[n−m]g[m](f * g)[n]=\\sum_{m=-\\infty}^{\\infty} f[m] g[n-m]=\\sum_{m=-\\infty}^{\\infty} f[n-m] g[m]\n(f∗g)[n]=m=−∞∑∞​f[m]g[n−m]=m=−∞∑∞​f[n−m]g[m]\n卷积的实质是对一个函数（如单位响应）在另一个函数（如输入信号）上的加权叠加，对于线性时不变系统，将单位响应和输入信号求卷积，就相当于把输入信号的各个时间点的单位响应加权叠加，就直接得到了输出信号。所以卷积的一个作用就是将一个函数拆分成一系列冲激，便于做其他计算与应用。\n\nconv 函数输出的数组长度与输入长度有何关系？如何将输出结果与时间向量相对应？\n\n设输入为x(k)x(k)x(k)和h(k)h(k)h(k)，具体分析见题目一的过程中，输出长度为len(x(k))+len(h(k))−1len(x(k))+len(h(k))-1len(x(k))+len(h(k))−1.输出结果的区域为[m1+n1,m2+n2][m_1+n_1,m_2+n_2][m1​+n1​,m2​+n2​],以此区域的时间向量与输出结果一一对应\n收获与感想\n通过本次实验，我学会了\n\n\n连续时间信号卷积及其 MATLAB 实现方法\nconv(u,v)求u*v，求解连续信号卷积时需*dt\n\n\n连续系统的冲激响应、阶跃响应及其 MATLAB 实现方法\n求解冲激响应——y = impulse(sys, t)\n求解阶跃响应——y = step(sys, t)\n\n\n利用 MATLAB 求 LTI 系统响应的方法\n\n利用lsin()函数求解零初始条件下微分方程数值解\n使用冲激响应卷积法，先求冲激响应，系统响应=冲激响应卷积输入信号\n\n\n\n进一步掌握了MATLAB的画图方法，增加图题、图示等\n\n\n并且进一步加深了对卷积和一些课上遇到的概念如零状态响应、零输入响应的理解，收获良多。\n","categories":["信号与系统"],"tags":["MATLAB实验"]},{"title":"信号与系统第三次实验","url":"/MATLAB%E4%BF%A1%E5%8F%B7%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/20373540_%E9%99%88%E6%98%A5%E8%95%8A_%E4%BF%A1%E5%8F%B7%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html","content":"实验内容\n题目一\n\n对周期为 4 的方波信号𝑓(𝑡)进行谐波分析，使用多张子图分别绘制 1 至 3 次谐波、1 至 9 次谐波、1 至 33 次谐波、1 至 99 次谐波叠加时的图像，并在每个子图中同时画出原始方波信号𝑓(𝑡)的图像。绘图区间至少包括两个完整的方波周期并有完整标注。可以 手算求解傅里叶级数系数，也可以通过代码仿真计算。𝑓(𝑡)波形如图 1 所示。\n\n\n**解：**该方波信号周期为4，且为奇函数，故an=0a_n=0an​=0，所以\nf(t)=∑n=1∞bnsin⁡(nωt)f(t)=\\sum_{n=1}^{\\infty} b_n \\sin (n \\omega t)\nf(t)=n=1∑∞​bn​sin(nωt)\n计算得到\nbn={0n=2,4,6,⋯2nπn=1,3,5,⋯b_n=\\left\\{\\begin{array}{cc}\n0 &amp; n=2,4,6, \\cdots \\\\\n\\frac{2}{n \\pi} &amp; n=1,3,5, \\cdots\n\\end{array}\\right.\nbn​={0nπ2​​n=2,4,6,⋯n=1,3,5,⋯​\n该方波的信号的傅立叶级数为\nf(t)=2π{sin⁡(π2t)+13sin⁡(π23t)+⋯+12n−1sin⁡[π2(2n−1)t]+⋯ }n=1,2,⋯f(t)=\\frac{2}{\\pi}\\left\\{\\sin (\\frac{\\pi}{2}t)+\\frac{1}{3} \\sin (\\frac{\\pi}{2}3 t)+\\cdots+\\frac{1}{2 n-1} \\sin [\\frac{\\pi}{2}(2 n-1) t]+\\cdots\\right\\} \\quad n=1,2, \\cdots\nf(t)=π2​{sin(2π​t)+31​sin(2π​3t)+⋯+2n−11​sin[2π​(2n−1)t]+⋯}n=1,2,⋯\n因此, 只要由 bnb_nbn​ 计算出 f(t)f(t)f(t) 各次谐波的振幅, 再根据各次谐波的频率, 即可利用 MATLAB 绘出周期方波的各次谐波叠加后的波形。\n代码\nm=50;t = -4:0.01:4; %时域波形的时间范围-2~2，采样间隔 0.01 n = round(length(t)/4); %根据周期方波信号的周期，计算 1/2 周期的数据点数f = [0.5*ones(n,1);-0.5*ones(n,1);0.5*ones(n,1);-0.5*ones(n+1,1)]; %构造周期方波信号y = zeros(m+1,max(size(t)));y(m+1,:) = f&#x27;;x = zeros(size(t)); kk = 1; for k=1:2:2*m-1 %循环显示谐波叠加图形 x = x+sin(pi/2*k*t)/k;  y((k+1)/2,:) = 2/pi*x; %计算各次谐波叠加和 if k==3||k==9||k==33||k==99    subplot(2,2,kk);    plot(t,y(m+1,:));     hold on;     plot(t,y((k+1)/2,:)); %绘制谐波叠加信号    hold off;     grid;     axis([-4 4 -1 1]);     title(strcat(&#x27;第1至&#x27;,num2str(k),&#x27;次谐波叠加&#x27;));     xlabel(&#x27;t&#x27;,&#x27;Fontsize&#x27;, 8);     kk =kk+1;  endend \n仿真图\n\n题目二\n\n求周期为 4 的信号𝑔(𝑡)的傅里叶级数系数{𝑎𝑘𝑎_𝑘ak​}，并绘制𝑔(𝑡)的幅度谱、相位谱。可以手算求解傅里叶级数系数，也可以通过代码仿真计算。𝑔(𝑡)的波形如图 2 所示。\n\n\n**解：**由图可知信号的周期为 T0=4\\mathrm{T}_0=4T0​=4, 所以 ω0=2π4=π2,g(t)\\omega_0=\\frac{2 \\pi}{4}=\\frac{\\pi}{2}, g(t)ω0​=42π​=2π​,g(t) 在区间 [0,4][0,4][0,4] 内的表达式为\ng(t)={4(t−12)0&lt;t≤1−1−t−3≤t&lt;0g(t)= \\begin{cases}4(t-\\frac{1}{2}) &amp; 0&lt; t \\leq 1 \\\\ -1-t &amp; -3 \\leq t &lt;0\\end{cases}\ng(t)={4(t−21​)−1−t​0&lt;t≤1−3≤t&lt;0​\n求 g(t)g(t)g(t) 的傅里叶级数系数CnC_nCn​\nCn=1T0∫−31g(t)e−jnω0tdt=14[∫014(t−12)e−jnω0tdt+∫−30(−1−t)e−jnω0tdt]C_n=\\frac{1}{T_0} \\int_{-3}^{1} g(t) e^{-j n \\omega_0 t} d t=\\frac{1}{4} [\\int_{0}^{1} 4( t-\\frac{1}{2}) e^{-j n\\omega_0 t} d t+ \\int_{-3}^{0} (-1-t) e^{-j n \\omega_0 t} d t]\nCn​=T0​1​∫−31​g(t)e−jnω0​tdt=41​[∫01​4(t−21​)e−jnω0​tdt+∫−30​(−1−t)e−jnω0​tdt]\n代码\nclear;clc;close all;syms cdt = 0.001;t = -4:dt:4;T = 4;w0 = 2 * pi / T;n = -10:10;Cn = zeros(size(n));for N = -10:10    ak=0;    ak=1/T*(int((-1-c) * exp(-1i * N * w0 * c),c,-3,0)+int((4 * c - 2) * exp(-1i * N * w0 * c) ,c,0,1));    Cn(N+11)=ak;endsubplot(2,1,1);stem(n,abs(Cn));ylabel(&#x27;Cn 的幅度谱&#x27;);grid;subplot(2,1,2);stem(n,angle(Cn));ylabel(&#x27;Cn 的相位谱&#x27;);grid;xlabel(&#x27;\\omega/\\omega_0&#x27;);\n仿真图\n\n题目三\n\n利用连续时间傅里叶级数的时移性质和时间反转性质求信号 𝑔(1 − 𝑡)的傅里叶级数系数{𝑏𝑘𝑏_𝑘bk​}，并绘制𝑔(1 − 𝑡)的幅度谱和相位谱；使用{𝑏𝑘𝑏_𝑘bk​}生成并绘制信号𝑔(1 − 𝑡)，以验证{𝑏𝑘𝑏_𝑘bk​}的正确性。{𝑏𝑘𝑏_𝑘bk​} 与{𝑎𝑘𝑎_𝑘ak​}的关系应在报告中给出。\n\n由连续时间傅里叶级数的时移性质和时间反转性质，在题目二的基础上更改\nbk=e−jkω0(−1)a−kb_k=e^{-jk\\omega_0(-1)}a_{-k}\nbk​=e−jkω0​(−1)a−k​\n频谱-相位图代码\nclear;syms cdt = 0.001;t = -4:dt:4;T = 4;w0 = 2 * pi / T;N=input(&#x27;N=&#x27;);n = -N:N;Cn = zeros(size(n));for k = -N:N    ak=1/T*(int((-1-c) * exp(-1i * k * w0 * c),c,-3,0)+int((4 * c - 2) * exp(-1i * k * w0 * c) ,c,0,1));    Cn(k+N+1)=ak;endDn = zeros(size(n));for i = 1:2*N+1    Dn(i) = Cn(2*(N+1)-i)*exp(-1i*n(i)*w0);endsubplot(2,2,1);stem(n,abs(Dn));ylabel(&#x27;Dn 的幅度谱&#x27;);grid on;axis([-10,10,0,0.7]);subplot(2,2,2);stem(n,angle(Dn));ylabel(&#x27;Dn 的相位谱&#x27;);grid on;axis([-10,10,-4,4]);subplot(2,2,[3 ,4]);g = zeros(size(t));for i = 1:2*N+1    g = g + Dn(i) * exp(1i*(i-N-1)*w0 * t);endplot(t, g);grid on;\n仿真图-N=50次的拟合情况\n\n题目四\n\n验证傅里叶级数的相乘性质。使用傅里叶级数的相乘性质求信号 ℎ(𝑡) = 𝑓(𝑡)𝑔(𝑡)的傅里叶级数系数{𝑐𝑘𝑐_𝑘ck​}，并绘制ℎ(𝑡)的幅度谱和相位谱；使用{𝑐𝑘𝑐_𝑘ck​}生成并绘制信号ℎ(𝑡)，以验证{𝑐𝑘𝑐_𝑘ck​}的正确性。{𝑐𝑘𝑐_𝑘ck​} 的推导过程应在报告中给出。\n\n解：  f(t)f(t)f(t) 和 g(t)g(t)g(t) 为两个周期为 T=4T=4T=4 的信号, 且$f(t) \\stackrel{\\mathcal{F S}}{\\leftrightarrow} a_k ，，，g(t) \\stackrel{\\mathcal{F S}}{\\leftrightarrow} b_k $\n则\nh(t)=f(t)g(t)↔FSck=ak∗bk=∑lalbk−lh(t)=f(t) g(t) \\stackrel{\\mathcal{F S}}{\\leftrightarrow} c_k=a_k * b_k=\\sum_l a_l b_{k-l}\nh(t)=f(t)g(t)↔FSck​=ak​∗bk​=l∑​al​bk−l​\n证明: f(t)g(t)↔FSck=1T∫Tf(t)g(t)e−jkω0tdt\\quad f(t) g(t) \\stackrel{\\mathcal{F S}}{\\leftrightarrow} c_k=\\frac{1}{T} \\int_T f(t) g(t) e^{-j k \\omega_0 t} d tf(t)g(t)↔FSck​=T1​∫T​f(t)g(t)e−jkω0​tdt\nck=1T∫T(∑mamejmω0t)(∑nbnejnω0t)e−jkω0tdt=1T∫T(∑m∑nambnej(m+n)ω0t)e−jkω0tdt=1T∑m∑n(∫Tambnej(m+n−k)ω0tdt)=∑m∑n{0,m+n≠kambn,m+n=k=∑lalbk−l\\begin{aligned}\nc_k &amp;=\\frac{1}{T} \\int_T\\left(\\sum_m a_m e^{j m \\omega_0 t}\\right)\\left(\\sum_n b_n e^{j n \\omega_0 t}\\right) e^{-j k \\omega_0 t} d t \\\\\n&amp;=\\frac{1}{T} \\int_T\\left(\\sum_m \\sum_n a_m b_n e^{j(m+n) \\omega_0 t}\\right) e^{-j k \\omega_0 t} d t \\\\\n&amp;=\\frac{1}{T} \\sum_m \\sum_n\\left(\\int_T a_m b_n e^{j(m+n-k) \\omega_0 t} d t\\right)=\\sum_m \\sum_n\\left\\{\\begin{array}{c}\n0, m+n \\neq k \\\\\na_m b_n, m+n=k\n\\end{array}=\\sum_l a_l b_{k-l}\\right.\n\\end{aligned}\nck​​=T1​∫T​(m∑​am​ejmω0​t)(n∑​bn​ejnω0​t)e−jkω0​tdt=T1​∫T​(m∑​n∑​am​bn​ej(m+n)ω0​t)e−jkω0​tdt=T1​m∑​n∑​(∫T​am​bn​ej(m+n−k)ω0​tdt)=m∑​n∑​{0,m+n=kam​bn​,m+n=k​=l∑​al​bk−l​​\n代码\nsyms cdt=0.01;t=-3:dt:1;%f g hf = 0.5*square(0.5*pi* t);% plot(t, f);% hold on;g=(-1-t).*(-t&gt;0)+4*(t-0.5).*(t&gt;0)+(-1).*(t==0);% plot(t, g);% hold on;h=f.*g;subplot(221)plot(t, h);ylabel(&#x27;h(t)&#x27;);grid on;%系数T = 4;w0 = 2 * pi / T;N=input(&#x27;N=&#x27;);n = -N:N;An = zeros(size(n));Bn = zeros(size(n));for k = -N:N    bk=1/T*(int((-1-c) * exp(-1i * k * w0 * c),c,-3,0)+int((4 * c - 2) * exp(-1i * k * w0 * c) ,c,0,1));    Bn(k+N+1)=bk;    ak=1/T*(int(0.5* exp(-1i * k * w0 * c),c,-3,-2)+int(-0.5* exp(-1i * k * w0 * c),c,-2,0)+int(0.5* exp(-1i * k * w0 * c),c,0,1));    % if k==0    %     ak=0    % else    %     ak=-1i/(k*pi);    % end    An(k+N+1)=ak;endm=-2*N:2*N;Cm=conv(An,Bn);subplot(222)stem(m,abs(Cm));axis([-10,10,0,0.3]);ylabel(&#x27;频谱图&#x27;);grid on;subplot(223)stem(m,angle(Cm));axis([-10,10,-4,4]);ylabel(&#x27;相位图&#x27;);grid on;h1 = zeros(size(t));for i = 1:4*N+1    h1 = h1 + Cm(i) * exp(1i*(i-2*N-1)*w0 * t);endsubplot(224)plot(t, h1);grid on;ylabel(strcat(num2str(N),&#x27;次谐波叠加的h(t)&#x27;)); \n仿真图-N=50次的拟合情况\n\n思考题\n\n连续时间傅里叶级数和离散时间傅里叶级数有何不同点，造成不同的原因是什么？\n\n离散时间周期信号的傅里叶级数是有限项级数，不存在收敛问题也没有吉柏斯现象，而在连续时间周期信号情况下是一个无穷级数。\n原因在于任何离散时间周期序列x[n]x[n]x[n]完全是由有限个参数（N个）来表征的，就是在一个周期内的N个序列值，傅里叶分析公式只是把这N个参数变换为一组等效的N个傅里叶系数值。相比之下一个连续时间周期信号在单个周期内有连续取值问题，这就要求用无限多个傅里叶系数来表示它，需要考虑项数趋于无穷多的求极限问题，这自然就产生了收敛问题。\n收获与感想\n通过本次实验我掌握了利用 MATLAB 实现对周期信号的频谱分析、实现信号的幅度调制的方法，直观地感受到傅里叶级数是如何进行展开与拟合地，加深了对周期信号傅里叶级数的理解。\n","categories":["信号与系统"],"tags":["MATLAB实验"]},{"title":"实验四 信号的傅里叶变换","url":"/MATLAB%E4%BF%A1%E5%8F%B7%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/20373540_%E9%99%88%E6%98%A5%E8%95%8A_%E4%BF%A1%E5%8F%B7%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.html","content":"实验内容\n题目一\n\n给定一连续 LTI 系统，描述其输入与输出关系的微分方程为：\n𝑑2(𝑦(𝑡))𝑑𝑡2+5𝑑(𝑦(𝑡))𝑑𝑡+3𝑦(𝑡)=𝑥(𝑡) \\frac{𝑑 ^2 (𝑦(𝑡))}{𝑑𝑡 ^2} + 5 \\frac{𝑑(𝑦(𝑡))}{ 𝑑𝑡} + 3𝑦(𝑡) = 𝑥(𝑡) \ndt2d2(y(t))​+5dtd(y(t))​+3y(t)=x(t)\n分别绘制系统的幅频响应、相频响应、频率响应的实部和频率响应的虚部（共四张图），要求频域上计算点数不少于 500 点，各个图标注清晰。其中，求解频率响应可以通过 freqs 函数实现；计算 复数幅度应使用 abs 函数，计算复数相角应使用 angle 函数，计算 复数实部应使用 real 函数，计算复数虚部应使用 imag 函数。\n\n代码\nclose all;clear all;a = [1 5 3];b = [1];w = -2 * pi : 0.01 : 2 * pi;h = freqs(b, a, w);%幅频响应、相频响应、频率响应的实部和频率响应的虚部（共四张图）ax1 = subplot(2, 2, 1);plot(w / pi, abs(h));grid;title(&#x27;幅频响应&#x27;);xlabel(&#x27;\\omega/\\pi&#x27;);ax3 = subplot(2, 2, 3);plot(w / pi, angle(h));grid;title(&#x27;相频响应&#x27;);xlabel(&#x27;\\omega/\\pi&#x27;);ax2 = subplot(2, 2, 2);plot(w / pi, real(h));grid;title(&#x27;频率响应的实部&#x27;);xlabel(&#x27;\\omega/\\pi&#x27;);ax4 = subplot(2, 2, 4);plot(w / pi, imag(h));grid;title(&#x27;频率响应的虚部&#x27;);xlabel(&#x27;\\omega/\\pi&#x27;);\n仿真图\n\n题目二\n\n使用数值以及符号计算方法计算以下信号的傅里叶变换，并分别绘制对应的幅度、相位谱：\n𝑥1(𝑡)=𝑒−2∣𝑡∣𝑠𝑖𝑛4𝑡𝑥2(𝑡)=𝑢(𝑡+3)−𝑢(𝑡−1)𝑥_1 (𝑡) = 𝑒 ^{−2|𝑡|} 𝑠𝑖𝑛 4𝑡 \\\\ 𝑥_2 (𝑡) = 𝑢(𝑡 + 3) − 𝑢(𝑡 − 1)\nx1​(t)=e−2∣t∣sin4tx2​(t)=u(t+3)−u(t−1)\n检查要求：两个信号，两种方法，对应的幅度谱和相位谱，一共 8 幅图，请标注清晰，各个信号的四幅图在同一个 figure 中。\n\n代码\nclose all;clear %符号法syms tx1_t = exp(-2*t) *sin(4*t)*heaviside(t)+ exp(2*t) *sin(4*t)*heaviside(-t);X1 = fourier(x1_t);x2_t=heaviside(t+3)-heaviside(t-1);X2=fourier(x2_t);w=[-10,10];%数值法dt = 0.001;dw = 0.01;t1 = -10: dt: 10;w1 = -10:dw:10;x11_t =  exp(-2*t1).*sin(4*t1).*heaviside(t1)+ exp(2*t1).*sin(4*t1).*heaviside(-t1);X11 = x11_t * exp(-1j * t1.&#x27; * w1) * dt;x21_t =  heaviside(t1+3)-heaviside(t1-1);X21 = x21_t * exp(-1j * t1.&#x27; * w1) * dt;%x1图像figure(1)subplot(2,2,1);fplot (abs(X1),w);title(&#x27;符号法作幅度谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;|X1(jw)|&#x27;);gridylim([0, 0.5])subplot(2,2,2);fplot (angle(X1),w);title(&#x27;符号法作相位谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;&lt;X1(jw)&#x27;);gridylim([-2, 2])subplot(2,2,3);plot (w1,abs(X11));title(&#x27;数值法作幅度谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;|X1(jw)|&#x27;);gridylim([0, 0.5])subplot(2,2,4);plot (w1,angle(X11));title(&#x27;数值法作相位谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;&lt;X1(jw)&#x27;);gridylim([-2, 2])%x2图像figure(2)subplot(2,2,1);fplot (abs(X2),w);title(&#x27;符号法作幅度谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;|X2(jw)|&#x27;);gridsubplot(2,2,2);fplot (angle(X2),w);title(&#x27;符号法作相位谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;&lt;X2(jw)&#x27;);gridsubplot(2,2,3);plot (w1,abs(X21));title(&#x27;数值法作幅度谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;|X2(jw)|&#x27;);gridsubplot(2,2,4);plot (w1,angle(X21));title(&#x27;数值法作相位谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;&lt;X2(jw)&#x27;);grid\n仿真图\nfigure1-x1(t)x_1(t)x1​(t)两种方法的图像\n\nfigure2-x2(t)x_2(t)x2​(t)两种方法的图像\n\n题目三\n\n验证傅里叶变换的性质：\n**线性性质：**计算5𝑥1(𝑡)+𝑥2(𝑡)5𝑥_1(𝑡) + 𝑥_2(𝑡)5x1​(t)+x2​(t)的傅里叶变换（直接计算与使用傅 里叶变换性质计算），分别使用两种方法绘制幅度谱和相位谱，并进行对比；\n**卷积性质：**计算𝑥1(𝑡)∗𝑥2(𝑡)𝑥_1(𝑡) ∗ 𝑥_2(𝑡)x1​(t)∗x2​(t)的傅里叶变换（直接计算与使用傅里 叶变换性质计算），分别使用两种方法绘制幅度谱和相位谱，并进 行对比。\n\n傅里叶变换的线性性质体现为：\nx1(t)↔FX1(jw),x2(t)↔FX2(jw)ax1(t)+bx2(t)↔FaX1(jw)+bX2(jw)x_1(t)\\stackrel{\\mathcal{F }}{\\leftrightarrow} X_1(jw),x_2(t)\\stackrel{\\mathcal{F }}{\\leftrightarrow} X_2(jw)\\\\\nax_1(t)+bx_2(t)\\stackrel{\\mathcal{F }}{\\leftrightarrow} aX_1(jw)+bX_2(jw)\nx1​(t)↔FX1​(jw),x2​(t)↔FX2​(jw)ax1​(t)+bx2​(t)↔FaX1​(jw)+bX2​(jw)\n卷积性质：\nx1(t)↔FX1(jw),x2(t)↔FX2(jw)x1(t)∗x2(t)↔FX1(jw)∗X2(jw)x_1(t)\\stackrel{\\mathcal{F }}{\\leftrightarrow} X_1(jw),x_2(t)\\stackrel{\\mathcal{F }}{\\leftrightarrow} X_2(jw)\\\\\nx_1(t)∗x_2(t)\\stackrel{\\mathcal{F }}{\\leftrightarrow} X_1(jw)∗X_2(jw)\nx1​(t)↔FX1​(jw),x2​(t)↔FX2​(jw)x1​(t)∗x2​(t)↔FX1​(jw)∗X2​(jw)\n代码\nclose all;clear dt=0.001;t = -10: dt: 10;dw = 0.1;w = -10:dw:10;x1_t = exp(-2*t) .*sin(4*t).*heaviside(t)+ exp(2*t) .*sin(4*t).*heaviside(-t);X1 = x1_t * exp(-1j * t.&#x27; * w) * dt;x2_t=heaviside(t+3)-heaviside(t-1);X2=x2_t * exp(-1j * t.&#x27; * w) * dt;y_t=5*x1_t+x2_t;Y=y_t * exp(-1j * t.&#x27; * w) * dt;X3=5*X1+X2;t1 = -20: dt: 20;w1=-20:dw:20;f_t=conv(x1_t,x2_t)*dt;F=f_t* exp(-1j * t1.&#x27; * w1) * dt;G=X1.*X2;%线性图像figure(1)subplot(2,2,1);plot (w,abs(X3));title(&#x27;5*X_1(jw)+X_2(jw)的幅度谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;|X3(jw)|&#x27;);gridylim([0,4]);subplot(2,2,2);plot (w,angle(X3));title(&#x27;5*X_1(jw)+X_2(jw)的相位谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;&lt;X3(jw)&#x27;);gridsubplot(2,2,3);plot (w,abs(Y));title(&#x27;fourier(5x_1(t)+x_2(t))的幅度谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;|Y(jw)|&#x27;);gridylim([0,4]);subplot(2,2,4);plot (w,angle(Y));title(&#x27;fourier(5x_1(t)+x_2(t))的相位谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;&lt;Y(jw)&#x27;);grid%卷积图像figure(2)subplot(2,2,1);plot (w,abs(G));title(&#x27;X_1(jw)X_2(jw)的幅度谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;|G(jw)|&#x27;);gridsubplot(2,2,2);plot (w,angle(G));title(&#x27;X_1(jw)X_2(jw)的相位谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;&lt;G(jw)&#x27;);gridsubplot(2,2,3);plot (w1,abs(F));title(&#x27;fourier(x_1(t)*x_2(t))的幅度谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;|F(jw)|&#x27;);xlim([-10,10]);gridsubplot(2,2,4);plot (w1,angle(F));title(&#x27;fourier(x_1(t)*x_2(t))的相位谱&#x27;);xlabel(&#x27;\\omega&#x27;);ylabel(&#x27;&lt;F(jw)&#x27;);xlim([-10,10]);grid\n仿真图\n\n\n题目四\n\n使用数值方法计算离散时间傅里叶变换：计算信号𝑥[𝑛]=(12)∣𝑛∣𝑥[𝑛] = ( \\frac{1 }{2} ) ^{|𝑛|}x[n]=(21​)∣n∣ 的傅里叶变换$ X(𝑒^{𝑗ω})$，绘制幅度谱与相位谱；\n\nx[n]x[n]x[n]是无限长的非周期序列，X(ejw)X(e^{jw})X(ejw)是周期的，对其在[0,π][0,\\pi][0,π]上求值\nX(ejw)=∑−∞∞x[n]e−jwn=∑0∞0.5ne−jwn+∑−∞00.5−ne−jwn=∑n=0∞(0.5ne−jwn+0.5nejwn)=1−0.521+0.52−coswX(e^{jw})=\\sum_{-\\infty}^{\\infty} x[n]e^{-jwn}=\\sum_{0}^{\\infty} 0.5^ne^{-jwn}+\\sum_{-\\infty}^{0} 0.5^{-n}e^{-jwn}\\\\\n=\\sum_{n=0}^{\\infty} (0.5^ne^{-jwn}+0.5^ne^{jwn})=\\frac{1-0.5^2}{1+0.5^2-cosw}\nX(ejw)=−∞∑∞​x[n]e−jwn=0∑∞​0.5ne−jwn+−∞∑0​0.5−ne−jwn=n=0∑∞​(0.5ne−jwn+0.5nejwn)=1+0.52−cosw1−0.52​\n代码\nclcclearclose alldw=0.01; w = -2*pi:dw:2*pi; X =0.75*1./( 1.25 -cos(w));magX = abs(X);angX = angle(X);subplot(2,1,1)plot(w/pi,magX);grid;title(&#x27;幅度谱&#x27;);xlabel(&#x27;frequency in pi units&#x27;);ylabel(&#x27;Magnitude&#x27;); subplot(2,1,2)plot(w/pi,angX);grid;title(&#x27;相位谱&#x27;)xlabel(&#x27;frequency in pi units&#x27;);ylabel(&#x27;Radians&#x27;); \n仿真图\n\n思考题\n\n使用数值方法计算信号的傅里叶变换时，误差主要有哪些来源？ 请以𝑥2(𝑡)𝑥_2 (𝑡)x2​(t)为例进行说明。\n\nf(𝑡)=𝑢(𝑡+3)−𝑢(𝑡−1)f(𝑡) = 𝑢(𝑡 + 3) − 𝑢(𝑡 − 1)\nf(t)=u(t+3)−u(t−1)\nf(t)f(t)f(t) 的傅里叶变换为:\nF(jω)=∫−∞+∞f(t)e−jωtdt=lim⁡Δt→0∑n=−∞+∞f(nΔt)e−jωnΔtΔtF(j \\omega)=\\int_{-\\infty}^{+\\infty} f(t) e^{-j \\omega t} d t=\\lim _{\\Delta t \\rightarrow 0} \\sum_{n=-\\infty}^{+\\infty} f(n \\Delta t) e^{-j \\omega n \\Delta t} \\Delta t\nF(jω)=∫−∞+∞​f(t)e−jωtdt=Δt→0lim​n=−∞∑+∞​f(nΔt)e−jωnΔtΔt\n若信号为时限信号, 当 Δt\\Delta tΔt 足够小, 项数 NNN 足够多时, 有:\nF(jω)=Δt∑n=0N−1f(t1+nΔt)e−jω(t1+nΔt)=Δt∗[f(t1),f(t2),…,f(t2N+1)]∗[e−jωt1,e−jωt2,…,e−jωt2N+1]T\\begin{aligned}\n&amp;F(j \\omega)=\\Delta t \\sum_{n=0}^{N-1} f\\left(t_1+n \\Delta t\\right) e^{-j \\omega\\left(t_1+n \\Delta t\\right)} \\\\\n&amp;=\\Delta t *\\left[f\\left(t_1\\right), f\\left(t_2\\right), \\ldots, f\\left(t_{2 N+1}\\right)\\right] *\\left[e^{-j \\omega t_1}, e^{-j \\omega t_2}, \\ldots, e^{-j \\omega t_{2 N+1}}\\right]^T\n\\end{aligned}\n​F(jω)=Δtn=0∑N−1​f(t1​+nΔt)e−jω(t1​+nΔt)=Δt∗[f(t1​),f(t2​),…,f(t2N+1​)]∗[e−jωt1​,e−jωt2​,…,e−jωt2N+1​]T​\n其中 [⋅]T[\\cdot]^T[⋅]T 表示矩阵转置。\n用 MATLAB 代码表示 FFF :\nF=f∗exp⁡(−1j∗t.′∗ω)∗dtF=f * \\exp \\left(-1 j * t .^{\\prime} * \\omega\\right) * d t\nF=f∗exp(−1j∗t.′∗ω)∗dt\n其中 f=[f(t1),f(t2),…,f(t2N+1)]f=\\left[f\\left(t_1\\right), f\\left(t_2\\right), \\ldots, f\\left(t_{2 N+1}\\right)\\right]f=[f(t1​),f(t2​),…,f(t2N+1​)],$ t=\\left[t_1, t_2, \\ldots, t_{2 N+1}\\right]=[-10,10+dt,10+2*dt,…,10],,, \\omega=\\left[\\omega_1, \\omega_2, \\ldots\\right]。。。 dt$ 是 ttt 的间隔， t.′t .^{\\prime}t.′ 表示 ttt 的转置。\n数值方法计算傅里叶变换的实质是用足够小的 Δt\\Delta tΔt和足够多的项数NNN进行求和模拟积分过程，实际过程中我们取定的==dtdtdt没有足够小==会造成误差，在==区间中取的点没有达到足够多==也造成了误差。对于==dwdwdw的取样==也会造成误差，绘图过程是集合对应画图，如果www的取点不够多，会造成某些取值处点缺失形成误差，如在一开始取dw=0.1dw=0.1dw=0.1时第三题的绘图结果，某些点处均产生明显上移：\n\n\n在计算信号的傅里叶变换方面，数值计算方法和符号计算方法各有什么优缺点？（提示：可从误差、运行时间、实现难度等方面考虑）\n\n\n\n数值计算方法需要信号是时限信号，因为计算机只能处理有限大小和有限数量的数，取样间隔的大小会对误差造成较大影响，在实现过程中需要考虑较多，实现难度大\n\n\n符号计算方法因为MatLab提供了函数，调用起来比较简单，实现难度小，误差相比数值法手动取样较小。\n\n\n运行时间测试：使用tic,toc分别计算符号法与数值法运行时间：\n\n\n\ndt\ndw\n符号法计算时间\n数值法计算时间\n\n\n\n\n0.005\n0.1\n0.101865 秒\n0.072984 秒\n\n\n0.001\n0.1\n0.049130 秒\n0.180165 秒\n\n\n0.001\n0.01\n0.052693 秒\n0.953460 秒\n\n\n0.0001\n0.1\n0.036236 秒\n1.181662 秒\n\n\n0.0001\n0.01\n0.063543 秒\n16.822756 秒\n\n\n0.00001\n0.1\n0.100490 秒\n26.060411 秒\n\n\n\n可以看到，符号法运行时间不受dt影响且速度较快，而数值法随着取样精度的增加运行时间急剧增加。\n\n\n实验收获与感想\n通过本次实验我学习到：\n\n利用MATLAB内置函数freqs计算系统幅频、相频响应的方法;\n熟练掌握了使用 MATLAB 进行傅里叶变换的两种方法——符号法与数值法，仔细比对不同因素对于数值法误差的影响，研究了两种方法的用法、原理与优缺点；\n利用MATLAB仿真图像验证傅里叶变换的线性性质与卷积性质\n\n此外，随着对MATLAB这一工具的熟练掌握，我还可以自己探究验证傅里叶变换的其他性质，将一些理论学习中的结论可视化，加深理解，做到理论与实践双管齐下。\n实际应用过程中常常用到快速傅里叶变换fft()函数，这一部分可以作为拓展内容进一步学习，通过本次实验的学习，收获良多。\n","categories":["信号与系统"],"tags":["MATLAB实验"]},{"title":"信号与系统第一次实验","url":"/MATLAB%E4%BF%A1%E5%8F%B7%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.html","content":"实验内容\n(1) f(t)=(2+e−t)u(t+1)f(t)=\\left(2+e^{-t}\\right) u(t+1)f(t)=(2+e−t)u(t+1),  (−2,4)(-2,4)(−2,4) 内\n代码\n引入预习手册中的Heaviside函数，直接编写函数即可\ncleart= -2:0.001:4;k=1;a=-1;f=(2+k*exp(a*t)).*Heaviside(t+1);plot(t,f);grid;xlabel(&#x27;t&#x27;);ylabel(&#x27;f(t)&#x27;);title(&#x27;f(t)=(2+e^-t)u(t+1)&#x27;);\n仿真图\n\n(2)$ f(t)=\\cos (t) u(\\sin (t)+0.3)$,  (−10,10)(-10,10)(−10,10) 内\n代码\ncleart= -10:0.001:10;f=cos(t).*Heaviside(sin(t)+0.3);plot(t,f);grid;xlabel(&#x27;t&#x27;);ylabel(&#x27;f(t)&#x27;);title(&#x27;f(t)=cos(t)u(sin(t)+0.3)&#x27;);\n仿真图\n\n（3）离散信号 f[n]=(2−0.8n)u[n]f[n]=(2-0.8 n) u[n]f[n]=(2−0.8n)u[n], 在自变量范围 (−2,4)(-2,4)(−2,4) 内绘图\n代码\n离散信号要用更改为生成阶跃序列的函数jyxl(),并使用stem绘制\nclearn= -2:1:4;f=(2-0.8*n).*jyxl(n);stem(n,f);grid;xlabel(&#x27;n&#x27;);ylabel(&#x27;f[n]&#x27;);title(&#x27;f[n] = (2 - 0.8n)u[n]&#x27;);\n仿真图\n\n(4) 在多张子图上绘制以下信号 (提示, 使用 subplot 函数)：\n\nf(t)=4sin⁡(3t+π2)f(t)=4 \\sin \\left(3 t+\\frac{\\pi}{2}\\right)f(t)=4sin(3t+2π​), 自变量范围 (−5,5)(-5,5)(−5,5) ；\n正弦序列 4∗sin⁡(π6k)4^* \\sin \\left(\\frac{\\pi}{6} k\\right)4∗sin(6π​k), 自变量范围 (−15,15)(-15,15)(−15,15) 。\n\n代码\ncleart= -5:0.001:5;f=4*sin(3*t+pi/2);subplot(2,1,1);plot(t,f);axis([-15, 15,-4,4])grid;xlabel(&#x27;t&#x27;);ylabel(&#x27;f(t)&#x27;);title(&#x27;f(t)= 4sin(3t+pi/2)&#x27;);k= -15:0.001:15;f=4*sin(pi/6*k);subplot(2,1,2);plot(k,f);grid;xlabel(&#x27;k&#x27;);ylabel(&#x27;f(k)&#x27;);title(&#x27;f(k)= 4sin(pi*k/6)&#x27;);axis([-15, 15,-4,4])\n仿真图\n\n(5) 在多张子图上绘制以下信号（提示, 使用 subplot 函数)\n\n\n近似的冲激信号 δ(t)\\delta(t)δ(t) ：\n\n\n方波信号, 要求 x&lt;0x&lt;0x&lt;0 时幅度为 ±1\\pm 1±1, 周期为 2 , 占空比为 30%;x≥030 \\% ; x \\geq 030%;x≥0 时 周期为 1 , 占空比为 60%60 \\%60% 。自变量取值范围 (−5,5)(-5,5)(−5,5) 。提示: 可采用 u(t)u(t)u(t) 函数辅助做出该信号。\n\n\n代码\nt0=-5;tf=5;dt=0.001;t1=0; t=[t0:dt:tf];st=length(t); n1=floor((t1-t0)/dt); x1=zeros(1,st);x1(n1)=1/dt;subplot(2,1,1);stairs(t,x1);grid minor;axis([-5,5,-1,20]);title(&#x27;近似的冲激信号&#x27;);x=-5:0.001:5;f=square(pi*x,30).*Heaviside(-x)+square(2*pi*x,60).*Heaviside(x);subplot(2,1,2);plot(x, f);grid minor;xlabel(&#x27;t&#x27;);ylabel(&#x27;f(t)&#x27;);title(&#x27;方波信号&#x27;);\n仿真图\n\n(6) 已知信号 f1=u(t+3.5)−u(t−3.5),f2=tcos⁡(πt)f_1=u(t+3.5)-u(t-3.5), f_2=t \\cos (\\pi t)f1​=u(t+3.5)−u(t−3.5),f2​=tcos(πt) 。\n\n\n在同一张图上绘制 f1(t)+f2(t)f_1(t)+f_2(t)f1​(t)+f2​(t) 和 f1(t)×f2(t)f_1(t) \\times f_2(t)f1​(t)×f2​(t) 的波形 (使用 hold on 语句);\n代码\nt= -10:0.001:10;f1=Heaviside(t+3.5)-Heaviside(t-3.5);f2=t.*cos(pi*t);plot(t,f1+f2);hold ongrid on;plot(t, f1.*f2);xlabel(&#x27;t&#x27;)legend(&#x27;f1(t)+f2(t)&#x27;,&#x27;f1(t)*f2(t)&#x27;)\n仿真图\n\n\n\n在多张子图上绘制 f1(t)×f2(t)f_1(t) \\times f_2(t)f1​(t)×f2​(t) 的积分与微分结果 (使用 subplot 函数, 推 存使用 integral 函数而不是 quad 函数进行积分)。\n写这个的时候有些波折，一开始没有搞清楚integral的用法，经过一番努力搞清楚它需要接收一个句柄函数，然后返回数值积分(double型)，这样就可以用它来模拟计算变上限积分（这样做可能有一些冗余，应该是有能够直接求积分的函数？暂时没有查到），其次是可以优化代码为将6—9行封装为一个脚本直接调用\n微分计算可以使用 diff 函数和语法 Y = diff(f)/h 求偏导数近似值，需要注意的是plot(x,y)函数中x与y的需要对应，第一个参数应变更为t(1:length(t)-1)\n代码\nt= -10:0.001:10;f1=Heaviside(t+3.5)-Heaviside(t-3.5);f2=t.*cos(pi*t);y=f1.*f2;g=@(t)( t.*cos(pi*t).*(((t+3.5)&gt;=0)-((t-3.5)&gt;=0)));for x=1:length(t)    F(x)= integral(g,-10,t(x));endsubplot(2,1,1);plot(t,F);grid on;xlabel(&#x27;t&#x27;);ylabel(&#x27;F(t)&#x27;);title(&#x27;f1(t)*f2(t)的积分结果&#x27;);subplot(2,1,2);plot(t(1:length(t)-1),diff(y)*1/dt);grid on;xlabel(&#x27;t&#x27;);ylabel(&#x27;h(t)&#x27;);title(&#x27;f1(t)*f2(t)的微分结果&#x27;);\n仿真图\n\n\n(7) 已知信号 f(t)=t×[u(t)−u(t−1)]f(t)=t \\times[u(t)-u(t-1)]f(t)=t×[u(t)−u(t−1)], 在多张子图上绘制 f(t−1),f(t+2)f(t-1), f(t+2)f(t−1),f(t+2), f(0.5t),f(2t)f(0.5 t), f(2 t)f(0.5t),f(2t) (使用 subplot 函数)。\n代码\n本题要求实现信号的尺度变换，按要求改变自变量即可\nt=-5:0.01:5;f2=(t+2).*(Heaviside(t+2)-Heaviside(t-1+2));subplot(2,2,1);plot(t, f2);grid on;xlabel(&#x27;t&#x27;);ylabel(&#x27;f(t+2)&#x27;);axis([-3, 3 ,0, 1]);title(&#x27;f(t+2)&#x27;);f1=(t-1).*(Heaviside(t-1)-Heaviside(t-2));subplot(2,2,2);plot(t, f1);grid on;xlabel(&#x27;t&#x27;);ylabel(&#x27;f(t-1)&#x27;);axis([-3, 3 ,0, 1]);title(&#x27;f(t-1)&#x27;);f3=0.5*t.*(Heaviside(0.5*t)-Heaviside(0.5*t-1));subplot(2,2,3);plot(t, f3);grid on;xlabel(&#x27;t&#x27;);ylabel(&#x27;f(0.5t)&#x27;);axis([-3, 3 ,0, 1]);title(&#x27;f(0.5t)&#x27;);f4=2*t.*(Heaviside(2*t)-Heaviside(2*t-1));subplot(2,2,4);plot(t, f4);grid on;xlabel(&#x27;t&#x27;);ylabel(&#x27;f(2t)&#x27;);axis([-3, 3 ,0, 1]);title(&#x27;f(2t)&#x27;);\n仿真图\n\n思考题\n\n\n什么是单位冲激信号？能够用 MATLAB 产生单位冲激信号吗？\n单位冲激信号指t≠0t\\neq 0t=0时,信号量恒为0,在t=0t=0t=0时信号量为无穷大,但是信号在时间上的积分为1.MATLAB不能产生真正的冲激信号,因为这是一种理想化模型,但是可以采用微积分思想模拟近似产生单位冲激信号.\n\n\nMATLAB 中如何编写自定义函数？模块化有什么优缺点？\n将自定义函数封装为另一个.m文件放在同一目录中,直接调用即可。\n模块化的优点是代码可维护性高、减少代码冗余提高开发效率、代码架构清晰一目了然。\n模块化的缺点是损耗性能，系统分层调用链长；不方便传递，需要装特定依赖。\n\n\ndiff 函数的功能是求数组元素之间的差分，如何用 diff 函数求连续函数的微分？\ndiff(f)将f视为函数值在某些域x上计算的向量，当把域x分到足够细就可以求微分了\n\n\n实验收获与感想\n通过本次实验我有如下一些收获：\n\n熟悉了MATLAB的基本使用，学会了使用其产生基本信号与进行运算\n进一步加深了对微积分思想的理解，学会利用MATLAB来模拟计算一些理想化模型\n对于不同的信号借以MATLAB的辅助分析认识的更加清晰\n\n此外，预习手册中有不少内容没有出现在实验中，但也应该理解并加以应用。尽管本实验只是对MATLAB的简单使用，但足以让我感受到MATLAB这一工具对于信号分析的巨大帮助，之后要勤加练习熟练使用来深化对于信号与系统的学习。\n同时也感谢教学团队制作的详细的预习手册，对于自学来讲有很大的帮助。\n","categories":["信号与系统"],"tags":["MATLAB实验"]},{"url":"/%E5%AF%86%E7%A0%81%E5%AD%A6/RSA.html","content":"算法原理\n\n模 pq\\mathrm{pq}pq 时高次同余方程的求解\n假设 p\\mathrm{p}p 和 q\\mathrm{q}q 是不同的素数, 并假设 e≥1e \\geq 1e≥1, 满足gcd⁡(e,(p−1)(q−1))=1\\operatorname{gcd}(e,(p-1)(q-1))=1\ngcd(e,(p−1)(q−1))=1\n则 eee 模 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 存在逆元， 即de≡1( mod (p−1)(q−1))d e \\equiv 1(\\bmod (p-1)(q-1))\nde≡1(mod(p−1)(q−1))\n则同余方程xe≡c( mod pq)x^{e} \\equiv c(\\bmod p q)\nxe≡c(modpq)\n有唯一解 x≡xed≡cd( mod pq)x \\equiv x^{ed} \\equiv c^{d}(\\bmod p q)x≡xed≡cd(modpq)\n安全性分析\n已知 p、qp 、qp、q 时该方程易解，敌手可以计算欧拉函数φ(n)=(p−1)(q−1)\\varphi(n)=(p-1)(q-1)φ(n)=(p−1)(q−1),然后利用扩展欧几里得算法计算eee对于φ(n)\\varphi(n)φ(n)的乘法逆元ddd,然后解密。\n而p、q\\mathrm{p、q}p、q未知时,已知公钥(e,n)(e,n)(e,n)求私钥等价于大数因子分解问题；已知一对(M,C)(M,C)(M,C)试图还原ddd,等价于离散对数问题。\n\n算法流程\n\n\n密钥生成过程:\n选择两个大素数 p、qp 、 qp、q, 计算公开模数:\nN=q∗pN=q * p\nN=q∗p\n选择公开加密指数 e，满足:\ngcd⁡(e,(p−1)(q−1))=1\\operatorname{gcd}(e,(p-1)(q-1))=1\ngcd(e,(p−1)(q−1))=1\n\n\nRSA 加密过程:\n将明文转化为整数 m\\mathrm{m}m，使用公钥N计算\nC≡me( mod N)C \\equiv m^{e}(\\bmod N)\nC≡me(modN)\n得到密文CCC\n\n\nRSA解密过程：\n已知p,qp,qp,q,计算ddd:\nde≡1( mod (p−1)(q−1))d e \\equiv 1(\\bmod (p-1)(q-1))\nde≡1(mod(p−1)(q−1))\n然后计算明文M：\nM≡Cd( mod N)M\\equiv C^d(\\bmod N)\nM≡Cd(modN)\n\n\n==在实际应用中，RSA加解密经过分组的数据段，这些数据段长度相等，固定长度时长度不足的数据段需要进行填充。==\n算法实现\n\n\n使用快速模幂运算计算，python中使用pow函数可以达到同样的效果。\n\n\n一般加密过程e比较小，可以快速实现，但解密时d比较大所以实际中利用中国剩余定理来加快计算：\nm≡cd( mod N)⇒{m1≡cd( mod p)m2≡cd( mod q)⇒{m1≡(c mod p)dmod  (p−1)( mod p)m2≡(c mod q)dmod  (q−1)( mod q)⇒m≡m1Aq+m2Bp( mod N=pq)A=q−1 mod pB=p−1 mod q\\begin{aligned}\n&amp; m \\equiv c^d(\\bmod N) \\\\\n&amp; \\Rightarrow\\left\\{\\begin{array}{l}\nm_1 \\equiv c^d(\\bmod p) \\\\\nm_2 \\equiv c^d(\\bmod q)\n\\end{array}\\right. \\\\\n&amp; \\Rightarrow\\left\\{\\begin{array}{l}\nm_1 \\equiv(c \\bmod p)^{d \\mod (p-1)}(\\bmod p) \\\\\nm_2 \\equiv(c \\bmod q)^{d \\mod (q-1)}(\\bmod q)\n\\end{array}\\right. \\\\\n\n&amp; \\Rightarrow m \\equiv m_1 A q+m_2 B p(\\bmod N=p q) \\\\\n&amp; A=q^{-1} \\bmod p \\quad B=p^{-1} \\bmod q \\\\\n&amp;\n\\end{aligned}\n​m≡cd(modN)⇒{m1​≡cd(modp)m2​≡cd(modq)​⇒{m1​≡(cmodp)dmod(p−1)(modp)m2​≡(cmodq)dmod(q−1)(modq)​⇒m≡m1​Aq+m2​Bp(modN=pq)A=q−1modpB=p−1modq​\n\n\n密钥产生——伪随机数发生器、执行素数判定测试（Miller Rabin）\n\n\n安全性优化——密钥生成阶段参数选择（否则会产生参数选取不当攻击）\n(1)使用大素数，同时要求p，q相差很大\n(2)尽量使用强素数p，q,强素数指p-1有很大的素因子。否则若p-1没有很大的质因数，而是由m个较小的质因数p1p2...pmp_1p_2...p_mp1​p2​...pm​组成。则p−1=p1a1p2a2...pmamp-1=p_1^{a_1}p_2^{a_2}...p_m^{a_m}p−1=p1a1​​p2a2​​...pmam​​，那么，要分解n则相对容易。(有相关论文可以找到详细分解方法)\n(3)d&gt;N14d&gt;N^\\frac{1}{4}d&gt;N41​,避免连分式理论\n\n\n对RSA的攻击方式\n因式分解攻击\n分解成功后按照算法原理中的内容可以计算得到明文m\n\n分解方式\n\n可以先查询网站http://factordb.com试试\n\n\n\n参数选取不当攻击\np，q相差要大(但不能过大)\n\n\n∣p−q∣|p-q|∣p−q∣小时，(p−q)24\\frac{(p-q)^2}{4}4(p−q)2​也小，此时(p+q)24\\frac{(p+q)^2}{4}4(p+q)2​稍大于nnn，即(p+q)2\\frac{(p+q)}{2}2(p+q)​稍大于n12n^\\frac{1}{2}n21​.\n(p+q)24−n=(p+q)24−pq=(p−q)24\\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4}\n4(p+q)2​−n=4(p+q)2​−pq=4(p−q)2​\n那么：\n\nwhile x&gt;n12x&gt;n^\\frac{1}{2}x&gt;n21​:\n if x2−n=y2x^2-n=y^2x2−n=y2:\n n=(x+y)(x−y)n=(x+y)(x-y)n=(x+y)(x−y)\n\n\n\np,q取值差异过大时，可以用开源项目yafu进行分解(过小也可以)，\n使用方法\n安装地址\n\n\nd特别小，e很大(接近N)\n\n\n问题描述\n  flag = s2n(flag)p = getPrime(1024)q = getPrime(1024)if p &lt; q:    p, q = q, passert q &lt; p &lt; 2 * qphi = (p - 1) * (q - 1)N = p * qd = randint(0, int(iroot(N, 4)[0]) // 3)print(f&#x27;N = &#123;N&#125;&#x27;)print(f&#x27;d = &#123;d&#125;&#x27;)e = invmod(d, phi)print(f&#x27;e = &#123;e&#125;&#x27;)c = pow(flag, e, N)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;N = 21327609432635697635661734492967514868032345219646509293473450728946796929125596264796686608077350282146808431543688814099354946988813695125850734043400446455515569653767982263228375866016212125033017742119349015072822178318196190745694850995570515630230752678292777440574778729120793338895028632923682027496271327472935942662500117169921554840041050071839641224638348524022215169727418319630285293394980617769914591506983043636592739835090149763802884920200300368993239366686843677366099965654860267609759882686378049533310393901183559714507043035045332273502601434654726043496991435324318063462466253726816633686491e = 18977835107309220930390004484766560831346929608900345454868912576417879395319152391809677007908654095951324946088077940809180932163517507338773363819836058226479707254933679974004335002153790380237807333376658330135322627930737835299410373663744954613372507542594748704398503555416693543828015836373800739443278657909905379530092958500438988035068330839162959013568315176411267327500693507377318806169025417092598473813234048525222602269176512302545380940501266666455315603787471273429334914051803354595877792553046681362881913923273953799258321308753602286651515092850863999625965095880385885087205694014033060741113c = 2951989543787250024227309988919939594167825226148750874062428524625014545445228307222640088545937734380203828988989321941362142365155595290586130523703955533644047842799047518117049515659231726842039527270329713890518786418601487875975864228006745361862477308867519292913016550436143764016127132235503694918940332463597026396960672403183254520332051492462851679089378927071373658225211987354898477962818171916800202243021649078952845125153161320695143579666246174891848723194556125740925439954503389599981696506010841328091656707182777225501527571416356759631836676820899342968642257694841513191347688952532566252238&#x27;&#x27;&#x27;\n\n\n攻击原理\n在数学中，连分数或繁分数即如下表达式\nx=a0+1a1+1a2+1a3+1⋱,Lx=a_{0}+\\frac{1}{a_{1}+\\frac{1}{a_{2}+\\frac{1}{a_{3}+\\frac{1}{\\ddots, L}}}}\nx=a0​+a1​+a2​+a3​+⋱,L1​1​1​1​\n由于 ed≡1( mod φ(N))e d \\equiv 1(\\bmod \\varphi(N))ed≡1(modφ(N)) ，所以存在整数 k\\mathrm{k}k ，满足\ned−kφ(N)=1e d-k \\varphi(N)=1\ned−kφ(N)=1\n由于 N=pq&gt;q2N=p q&gt;q^{2}N=pq&gt;q2, 即 q&lt;Nq&lt;Nq&lt;N ，所以\n0&lt;N−φ(N)=p+q−1&lt;2q+q−1&lt;3q&lt;3N⇒∣eN−kd∣=∣ed−kNdN∣=∣1+k(φ(N)−N)dN∣&lt;3kNdN=3kdN\\begin{gathered}\n0&lt;N-\\varphi(N)=p+q-1&lt;2 q+q-1&lt;3 q&lt;3 \\sqrt{N} \\\\\n\\Rightarrow\\left|\\frac{e}{N}-\\frac{k}{d}\\right|=\\left|\\frac{e d-k N}{d N}\\right|=\\left|\\frac{1+k(\\varphi(N)-N)}{d N}\\right|&lt;\\frac{3 k \\sqrt{N}}{d N}=\\frac{3 k}{d \\sqrt{N}}\n\\end{gathered}\n0&lt;N−φ(N)=p+q−1&lt;2q+q−1&lt;3q&lt;3N​⇒​Ne​−dk​​=​dNed−kN​​=​dN1+k(φ(N)−N)​​&lt;dN3kN​​=dN​3k​​\n由于 k&lt;dk&lt;dk&lt;d, 所以 3k&lt;3d&lt;N143k&lt;3d&lt;N^{\\frac{1}{4}}3k&lt;3d&lt;N41​, 即\n∣eN−kd∣&lt;1dN14⇒∣eN−kd∣&lt;13d2\\left|\\frac{e}{N}-\\frac{k}{d}\\right|&lt;\\frac{1}{d N^{\\frac{1}{4}}} \\quad \\Rightarrow \\quad \\left|\\frac{e}{N}-\\frac{k}{d}\\right|&lt;\\frac{1}{3 d^{2}}\n​Ne​−dk​​&lt;dN41​1​⇒​Ne​−dk​​&lt;3d21​\n由连分数理论，此时 kd\\frac{k}{d}dk​ 是 eN\\frac{e}{N}Ne​ 的一个收敛子：\n计算 eN\\frac{e}{N}Ne​ 的连分数展开, 依次算出每一个渐进分数。因为 eN&gt;kd\\frac{e}{N}&gt;\\frac{k}{d}Ne​&gt;dk​,所以 eN\\frac{e}{N}Ne​ 的渐进分数覆盖了 kd∘\\frac{k}{d^{\\circ}}d∘k​ 。 就是说 eN\\frac{e}{N}Ne​ 的渐进分数里有等于 kd\\frac{k}{d}dk​ 的分数。接着验证 k,dk, dk,d 是否满足条件就求得了 k,dk, dk,d 的值\n\n\n攻击代码\n  # numerator(n):分子, denominator(d)：分母def t_cf(n, d):  # 将分数 x/y 转为连分数的形式    res = []    while d:        res.append(n // d)        n, d = d, n % d    return resdef cf(sub_res):    # 得到渐进分数的分母和分子    n, d = 1, 0    for i in sub_res[::-1]:  # 从后面往前循环        d, n = n, i * n + d    return d, ndef list_fraction(x, y):     # 列出每个渐进分数    res = t_cf(x, y)    res = list(map(cf, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数    return resdef get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q(解二元一次方程)    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)    return x1, x2def wienerAttack(e, n):    for (d, k) in list_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除            continue        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)            continue        phi = (e * d - 1) // k  # 这个结果就是 φ(n)            px, qy = get_pq(1, n - phi + 1, n)        if px * qy == n:            p, q = abs(int(px)), abs(int(qy))  # 可能会得到两个负数，负负得正未尝不会出现            d = gmpy2.invert(e, (p - 1) * (q - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d            return d    print(&quot;求解d失败&quot;)d =  wienerAttack(e,N)#print(d)m=int(pow(c,d,N))flag = n2s(m)print(flag)\n\n\n选择密文攻击/中间人攻击\n\n\nRSA算法具有同态特点，即对任意x1,x2∈Znx_1,x_2\\in Z_nx1​,x2​∈Zn​,有Ek(x1,x2)=Ek(x1)Ek(x2)E_k(x_1,x_2)=E_k(x_1)E_k(x_2)Ek​(x1​,x2​)=Ek​(x1​)Ek​(x2​).\n攻击人截获密文ccc,发出伪造密文recr^ecrec(rrr为随机数),可以获得对应明文m‘=(rec)d=redcd=rm( mod N)m^`=(r^ec)^d=r^{ed}c^d=rm(\\bmod N)m‘=(rec)d=redcd=rm(modN),得\nm=m‘r−1m=m^`r^{-1}\nm=m‘r−1\n\n\nRSA-OAEP可抗击适应性选择密文攻击（EUROCRYPT’94，Bellare-Rogaway, Optimal Asymmetric Encryption Padding (OAEP))\nRSA最优非对称加密填充 (RSA-OAEP) 的密钥参数 (N,e,d,G,H,n,k0,k1)\\left(N, e, d, G, H, n, k_{0}, k_{1}\\right)(N,e,d,G,H,n,k0​,k1​) 满足:\n\n\n(N,e,d)(N, e, d)(N,e,d) 是RSA的密钥, 其中\nd=e−1( mod φ(N))d=e^{-1}(\\bmod \\varphi(N))d=e−1(modφ(N)), 并且 ∣Nf=k=n+k0+k1,n\\mid N f=k=n+k_{0}+k_{1}, \\mathrm{n}∣Nf=k=n+k0​+k1​,n 是明文消息的长度,\n\n\nG,H\\mathrm{G}, \\mathrm{H}G,H是两个杂湊函数, 且满足G:{0,1}k0→{0,1}k−k0,H:{0,1}k−k0→{0,1}k0G:\\{0,1\\}^{k_{0}} \\rightarrow\\{0,1\\}^{k-k_{0}}, H:\\{0,1\\}^{k-k_{0}} \\rightarrow\\{0,1\\}^{k_{0}}G:{0,1}k0​→{0,1}k−k0​,H:{0,1}k−k0​→{0,1}k0​\n\n\n设 (N,e)(N, e)(N,e) 是Alice的RSA公钥, ddd 是私钥。\n加密过程:\n为了发送一个消息 m∈{0,1}nm \\in\\{0,1\\}^{n}m∈{0,1}n, 给Alice, Bob执行以下几步计算:\n\nr←U{0,1}k0;s←(m∥0k1)⨁G(r^);t=r⨁H(s)r \\leftarrow_{U}\\{0,1\\}^{k_{0}} ; s \\leftarrow\\left(m \\| 0^{k_{1}}\\right) \\bigoplus G(\\hat{r}) ; t=r \\bigoplus H(s)r←U​{0,1}k0​;s←(m∥0k1​)⨁G(r^);t=r⨁H(s)\n如果 (s∥t≥N)(s \\| t \\geq N)(s∥t≥N), 则返回 VaV_{a}Va​\nc←(s∥t)e( mod N)c \\leftarrow(s \\| t)^{e}(\\bmod N)c←(s∥t)e(modN)\n所得密文为 ccc\n\n解密过程:\n收到密文 ccc 后, Alice执行以下几步计算:\n\ns∣∣t←cd( mod N)s|| t \\leftarrow c^{d}(\\bmod N)s∣∣t←cd(modN) 满足 ∣s∣=n+k11k−k0,∣t∣=k0|s|=n+k_{1} \\underset{k}{1}-k_{0},|t|=k_{0}∣s∣=n+k1​k1​−k0​,∣t∣=k0​\nu←t⨁H(s);v=s⨁G(u)u \\leftarrow t \\bigoplus H(s) ; v=s \\bigoplus G(u)u←t⨁H(s);v=s⨁G(u)\n输出 {m, 若 v=m∥0k1 拒绝, 其他 \\left\\{\\begin{array}{c}m, \\text { 若 } v=m \\| 0^{k_{1}} \\\\ \\text { 拒绝, 其他 }\\end{array}\\right.{m, 若 v=m∥0k1​ 拒绝, 其他 ​\n\n\n\n\n\n共模攻击\n对于给定的模数N，最多应该只使用一个加密指数，不同用户间不要共享N\n\n攻击原理\n用公开指数e1,e2e_1,e_2e1​,e2​加密同一段明文mmm，且公开模数NNN不变.\n若截获密文\nc1≡m1e(modN)c_1≡m^e_1 (mod N)c1​≡m1e​(modN)和 c2≡m2e(modN)c_2≡m^e_2 (mod N)c2​≡m2e​(modN)\n可解出u、vu、vu、v:  e1u+e2v=gcd⁡(e1,e2)e_1u+e_2v=gcd⁡(e_1,e_2)e1​u+e2​v=gcd⁡(e1​,e2​)\n进而   c1uc2v≡me1ume2v≡mgcd⁡(e1,e2)(modN)c_1^uc_2^v≡m^e1um^e2v≡m^{gcd⁡(e1,e2)}  (mod N)c1u​c2v​≡me1ume2v≡mgcd⁡(e1,e2)(modN)\n若解得gcd(e1,e2)=1gcd(e_1,e_2)=1gcd(e1​,e2​)=1，可直接得到mmm\n\n低指数广播攻击\n同一份明文使用不同模数和相同指数多次加密，可以考虑用中国剩余定理破解，然后直接开e次\nc1=me(mod  n1)c2=me(modn2)…cn=me(modnn)⇒me≡x(mod  n1…nn)\\begin{gather*}\nc_1=m^e (mod ~~n_1)\\\\\nc_2=m^e (mod n_2)\\\\\n\\dots\\\\\nc_n=m^e (mod n_n)\\\\\n\\Rightarrow m^e≡x(mod~~ n_1…n_n)\n\\end{gather*}\nc1​=me(mod  n1​)c2​=me(modn2​)…cn​=me(modnn​)⇒me≡x(mod  n1​…nn​)​\ne很小时可以直接爆破\n循环攻击\n在构造n时应选择𝑝和q，使得𝑝-1和q-1有大的素因子。一般选择𝑝和 (𝑝 − 1)/2 均是素数.\n否则进行重复加密：\nce≡(me)me2( mod n)ce2≡(me)e2≡me3( mod n)⋯cet−1≡(me)et−1≡met( mod n)cet≡(me)et≡met+1( mod n)\\begin{aligned}\n&amp;c^{e} \\equiv\\left(m^{e}\\right) m^{e^{2}}(\\bmod n) \\\\\n&amp;c^{e^{2}} \\equiv\\left(m^{e}\\right)^{e^{2}} \\equiv m^{e^{3}}(\\bmod n) \\\\\n&amp;\\cdots \\\\\n&amp;c^{e^{t-1}} \\equiv\\left(m^{e}\\right)^{e^{t-1}} \\equiv m^{e^{t}}(\\bmod n) \\\\\n&amp;c^{e^{t}} \\equiv\\left(m^{e}\\right)^{e^{t}} \\equiv m^{e^{t+1}}(\\bmod n)\n\\end{aligned}\n​ce≡(me)me2(modn)ce2≡(me)e2≡me3(modn)⋯cet−1≡(me)et−1≡met(modn)cet≡(me)et≡met+1(modn)​\n若 met+1≡c( mod n)m^{e^{t+1}} \\equiv c(\\bmod n)met+1≡c(modn), 即 (met)e≡c( mod n)\\left(\\mathrm{m}^{e^{t}}\\right)^{e} \\equiv c(\\bmod n)(met)e≡c(modn) ，则有 met≡m( mod n)m^{e^{t}} \\equiv m(\\bmod n)met≡m(modn), 即:\ncet−1≡m( mod n)=1Nc^{e^{t-1}} \\equiv m(\\bmod n)=\\frac{1}{N}\ncet−1≡m(modn)=N1​\n可以恢复出明文，但这种攻击方式只有在t比较小时才可行，所以t应该很大\nmet≡m( mod  n),met−1≡1( mod  n)m^{e^t}\\equiv m(\\bmod~ n),m^{e^t-1}\\equiv 1(\\bmod~ n)met≡m(mod n),met−1≡1(mod n)\n设m在模n下的阶为kkk,k∣et−1⇒et≡1( mod  k)k|e^t-1 \\Rightarrow e^t\\equiv 1(\\bmod~k)k∣et−1⇒et≡1(mod k),所以t∣φ(k)t|\\varphi(k)t∣φ(k),且k∣φ(n)k|\\varphi(n)k∣φ(n),要保证t很大需要p−1,q−1p-1,q-1p−1,q−1有很大的素因子，即为强素数。\n消息隐藏\n用RSA加密后还是本身的点为不动点.ye≡y  mod  ny^e\\equiv y~\\bmod~nye≡y mod n.\n由数论和中国剩余定理RSA的不动点总数(详细证明我没了解)为\n$$(1 + 𝑔cd(𝑒 − 1, 𝑝 − 1))(1 + 𝑔cd(𝑒 − 1, 𝑞 − 1)$$\n因e-1, p-1, q-1均为偶数， RSA的不动点至少有9个。\n私钥ddd相关信息泄露\n定义dp=ddp=d%(p-1),dq=d%(q-1)dp=d,倘若敌手已知dpdpdp，可进行如下攻击：\ndp=d%(p−1)d=k1(p−1)+dp即ed=ek1(p−1)+dp∗e已知ed≡1 mod φ(N)所以ed=k2∗φ(N)+1所以ek1(p−1)+dp∗e=k2∗φ(N)+1整理得dp∗e=[k2∗(q−1)−k1∗e](p−1)+1因为dp&gt;p−1所以e&gt;[k2∗(q−1)−k1∗e]令X=[k2∗(q−1)−k1∗e](意味着这样的数只有有限个)，穷举即可\\begin{gather*}\ndp=d\\%(p-1)\\\\\n d=k_1(p-1)+dp\\\\\n即ed=ek_1(p-1)+dp*e\\\\\n已知 ed≡1~mod~φ(N)\\\\\n所以ed=k_2*φ(N)+1\\\\\n所以ek_1(p-1)+dp*e=k_2*φ(N)+1\\\\\n整理得dp*e=[k_2*(q-1)-k_1*e](p-1)+1\\\\\n因为dp&gt;p-1 所以e&gt; [k_2*(q-1)-k_1*e]\\\\\n令X=[k_2*(q-1)-k_1*e](意味着这样的数只有有限个)，穷举即可\n\\end{gather*}\ndp=d%(p−1)d=k1​(p−1)+dp即ed=ek1​(p−1)+dp∗e已知ed≡1 mod φ(N)所以ed=k2​∗φ(N)+1所以ek1​(p−1)+dp∗e=k2​∗φ(N)+1整理得dp∗e=[k2​∗(q−1)−k1​∗e](p−1)+1因为dp&gt;p−1所以e&gt;[k2​∗(q−1)−k1​∗e]令X=[k2​∗(q−1)−k1​∗e](意味着这样的数只有有限个)，穷举即可​\n"},{"title":"古典密码学","url":"/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6.html","content":"主要记录密码编码学与网络安全-第七版的部分课后习题详解\n\n\n仿射 Caesar 密码的密钥[a,b][a,b][a,b]共有 311 种合法取值\n==12×26−112\\times 26-112×26−1种，需要去除a=1,b=0a=1,b=0a=1,b=0的平凡解==\n\n\n【证明题】对于乘法代替密码，当且仅当𝑔𝑐𝑑(𝑘,𝑝)=1𝑔𝑐𝑑(𝑘, 𝑝) = 1gcd(k,p)=1时，𝐸𝑘𝐸_𝑘Ek​才是一一映射。\n1）==(必要性)⇒\\Rightarrow⇒==\n若𝑔𝑐𝑑(𝑘,𝑝)=1𝑔𝑐𝑑(𝑘, 𝑝) = 1gcd(k,p)=1，下证EkE_kEk​为一一映射：\n单射：对任意i,j,k∈Zp,i≠ji,j,k \\in Z_p,i\\neq ji,j,k∈Zp​,i=j都有jk≢ik ( mod p)jk \\not\\equiv ik\\ (\\bmod p)jk≡ik (modp)否则由消去律有x1=x2x_1=x_2x1​=x2​,与x1,x2x_1,x_2x1​,x2​的选取不符，故EkE_kEk​为单射；\n满射：对任意y∈Zpy \\in Z_py∈Zp​，由加密公式有y≡kx ( mod p)y \\equiv kx\\ (\\bmod p)y≡kx (modp),又𝑔𝑐𝑑(𝑘,𝑝)=1𝑔𝑐𝑑(𝑘, 𝑝) = 1gcd(k,p)=1所以k−1 mod pk^{-1}\\bmod pk−1modp存在，因此存在x≡k−1y ( mod p)∈Zpx \\equiv k^{-1}y\\ (\\bmod p)\\in Z_px≡k−1y (modp)∈Zp​，故EkE_kEk​为满射。\n综上，EkE_kEk​为一一映射。\n2）==(充分性)⇐\\Leftarrow⇐==\n若EkE_kEk​为一一映射，则EkE_kEk​的逆映射DkD_kDk​也为一一映射，对任意y∈Zpy \\in Z_py∈Zp​，由加密公式y≡kx ( mod p)y \\equiv kx\\ (\\bmod p)y≡kx (modp),必有k−1 mod pk^{-1}\\bmod pk−1modp存在，即存在ku≡1 ( mod p)ku \\equiv 1\\ (\\bmod p)ku≡1 (modp)，即存在u,vu,vu,v满足uk+vp=1uk+vp=1uk+vp=1,因此(k,p)=1(k,p)=1(k,p)=1\n\n\n(1) basilisk to leviathan blake is contact\nstring=&quot;thesnowlaythickonthestepsandthesnowflakesdr        ivenbythewinlookedblackintheheadlightsofthecars&quot;list1=list(string)lists=list(set(list1))lists.sort(key=list1.index)key=&quot;&quot;.join(lists)C=&quot;SIDKHKDM AF HCRKIABIE SHIMC KD LFEAILA&quot;for i in range(ord(&#x27;a&#x27;), ord(&#x27;z&#x27;)+1):   if chr(i) not in lists:      key+=chr(i)for i in range(len(C)):   if(C[i]==&#x27; &#x27;):      print(&#x27; &#x27;,end=&quot;&quot;)   else:      print(key[(ord(C[i].lower())-ord(&#x27;a&#x27;))],end=&quot;&quot;)\n助记词去重并将剩余字母顺序排列得到对照表key，然后替换即可\n(2) 虽然单表代替密码有大于56位DES的密钥空间，但仍不安全，可以基于英文语言规律破译，统计密文中的词频，与英语中的字母频率对照，密文越长一般破译精确度越高。\n(3) 尽量涵盖所有字母，使密钥中保持原来顺序的字符串较少。\n\n\n(1) 分组:mu,st,se,ey,ou,ov,er,ca,do,ga,nw,es,tc,om,in,ga,to,nv,ex\n  密文：UZTBDLGZPNNWLGTGTUEROVLDBDUHFPERHWQSRZ\n(2) 密文：UZTBDLGZPNNWLGTGTUEROVLDBDUHFPERHWQSRZ\n\n\n\nL\nA\nR\nG\nE\n\n\n\n\nS\nT\nB\nC\nD\n\n\nF\nH\nI/J\nK\nM\n\n\nN\nO\nP\nQ\nU\n\n\nV\nW\nX\nY\nZ\n\n\n\n(3) 两个矩阵加密得到的密文一样。通过观察发现可以第一个矩阵通过行列变化得到第二个矩阵。因为通过行列变化不影响Playfair规则下的替换，推广结论为若两个密钥生成的Playfair矩阵可以通过一定行列变化相互转换则其加密同一明文得到相同密文。\n(4) 5x5矩阵共有25!种排列，其中每个元素有25个位置可以放，固定其余字母随其一起移动，即每个元素有25种等效矩阵，计算得：\n25!25=24!=620,448,401,733,239,439,360,000≈279\\begin{aligned}\n\\frac{25!}{25}=24!&amp;=620,448,401,733,239,439,360,000\\\\\n&amp;\\approx 2^{79}\n\\end{aligned}2525!​=24!​=620,448,401,733,239,439,360,000≈279​\n\n\n(1) Hill密码加密: C=MK mod 26C=M K \\bmod 26C=MKmod26\n加密过程：将明文两两分组与数字对应如：me et对应 (13,5)(5,20)(13,5)(5,20)(13,5)(5,20) 计算:\n(135)(9457) mod 26=(14287) mod 26=(129)=(LI)\\left(\\begin{array}{ll}13 &amp; 5\\end{array}\\right)\\left(\\begin{array}{ll}9 &amp; 4 \\\\ 5 &amp; 7\\end{array}\\right) \\bmod 26=\\left(\\begin{array}{ll}142 &amp; 87\\end{array}\\right) \\bmod 26=\\left(\\begin{array}{ll}12 &amp; 9\\end{array}\\right)=\\left(\\begin{array}{ll}L &amp; I\\end{array}\\right)(13​5​)(95​47​)mod26=(142​87​)mod26=(12​9​)=(L​I​)\n(520)(9457) mod 26=(145160) mod 26=(154)=(OD)\\left(\\begin{array}{ll}5 &amp; 20\\end{array}\\right)\\left(\\begin{array}{ll}9 &amp; 4 \\\\ 5 &amp; 7\\end{array}\\right) \\bmod 26=\\left(\\begin{array}{ll}145 &amp; 160\\end{array}\\right) \\bmod 26=\\left(\\begin{array}{ll}15 &amp; 4\\end{array}\\right)=\\left(\\begin{array}{ll}O &amp; D\\end{array}\\right)(5​20​)(95​47​)mod26=(145​160​)mod26=(15​4​)=(O​D​)\n类似计算可得最终密文为LIOD LI EN SYNK\n(2) 求解：\ndet⁡(9457) mod 26=43\\operatorname{det}\\left(\\begin{array}{ll}\n9 &amp; 4 \\\\\n5 &amp; 7\n\\end{array}\\right) \\bmod 26=43\ndet(95​47​)mod26=43\n(9457)−1 mod 26=23(7−4−59) mod 26=(5121525)\\left(\\begin{array}{ll}9 &amp; 4 \\\\ 5 &amp; 7\\end{array}\\right)^{-1} \\bmod 26=23\\left(\\begin{array}{cc}7 &amp; -4 \\\\ -5 &amp; 9\\end{array}\\right) \\bmod 26=\\left(\\begin{array}{cc}5 &amp; 12 \\\\ 15 &amp; 25\\end{array}\\right)(95​47​)−1mod26=23(7−5​−49​)mod26=(515​1225​)\n即 K−1=(5121525)K^{-1}=\\left(\\begin{array}{cc}5 &amp; 12 \\\\ 15 &amp; 25\\end{array}\\right)K−1=(515​1225​)\n验证: (129154)(5121525) mod 26=(135520)=(meet)\\left(\\begin{array}{ll}12 &amp; 9 \\\\ 15 &amp; 4\\end{array}\\right)\\left(\\begin{array}{cc}5 &amp; 12 \\\\ 15 &amp; 25\\end{array}\\right) \\bmod 26=\\left(\\begin{array}{cc}13 &amp; 5 \\\\ 5 &amp; 20\\end{array}\\right)=\\left(\\begin{array}{cc}m &amp; e \\\\ e &amp; t\\end{array}\\right)(1215​94​)(515​1225​)mod26=(135​520​)=(me​et​)\n(3) 对于一个 m×mm \\times mm×m 的 Hill 密 码, 假如有 mmm 个明密文对, 每个长度都是 mmm, 定义 Pj=\\boldsymbol{P}_{\\mathrm{j}}=Pj​= (p1jp1j⋯pmj)\\left(p_{1 j} \\mathrm{p}_{1 j} \\cdots p_{m j}\\right)(p1j​p1j​⋯pmj​) 和 Cj=(c1jc1j⋯cmj)\\boldsymbol{C}_{\\mathrm{j}}=\\left(c_{1 j} c_{1 j} \\cdots c_{m j}\\right)Cj​=(c1j​c1j​⋯cmj​), 使得对每个 Cj\\boldsymbol{C}_jCj​ 和 PjK(1⩽j⩽m)\\boldsymbol{P}_j \\boldsymbol{K}(1 \\leqslant j \\leqslant m)Pj​K(1⩽j⩽m) 都有 Cj=PjK\\boldsymbol{C}_j=\\boldsymbol{P}_j \\boldsymbol{K}Cj​=Pj​K, 其中 K\\boldsymbol{K}K 是末知的矩阵形密钥。现在定义两个 m×mm \\times mm×m 的矩阵 X=(pij)\\boldsymbol{X}=\\left(p_{i j}\\right)X=(pij​)\n和 Y=(cij)\\boldsymbol{Y}=\\left(c_{i j}\\right)Y=(cij​) 。那么我们可以得出矩阵等式 Y=XK\\boldsymbol{Y}=\\boldsymbol{X} \\boldsymbol{K}Y=XK, 若 X\\boldsymbol{X}X 可逆, 则可得 K=\\boldsymbol{K}=K=\nX−1Y\\boldsymbol{X}^{-1} \\boldsymbol{Y}X−1Y 。若 X\\boldsymbol{X}X 不可逆, 那么可以另找 X\\boldsymbol{X}X 和对应的 Y\\boldsymbol{Y}Y, 直至得到一个可逆的 X\\boldsymbol{X}X 。简而言 之通过明密文矩阵容易算出密钥 K\\boldsymbol{K}K ，因为加密过程是线性的。\n(4) 分别构建nxn的明密文矩阵，如果明文矩阵可逆，则可计算密钥矩阵\n\n\n(1) 密文为：pbvwetlxozr\n(2) 密文为：beokjdmsxzpmh\n(3) 密钥为：zewdwptftvmie\n\n\n(1) 7∗13∗13∗13∗13=1428057*13*13*13*13=1428057∗13∗13∗13∗13=142805\n(2) 7∗13∗13∗13∗13=1428057*13*13*13*13=1428057∗13∗13∗13∗13=142805\n(3) 13∗13∗13∗13=2856113*13*13*13=2856113∗13∗13∗13=28561\n(4) 10∗13∗13∗13∗13=28561010*13*13*13*13=28561010∗13∗13∗13∗13=285610\n(5) 2∗26∗26∗2=27042*26*26*2=27042∗26∗26∗2=2704\n(6) 24∗(13∗13−1)∗132^4*(13*13-1)*1324∗(13∗13−1)∗13\n(7) 13的倍数：376483764837648\n(8) 26的倍数：235302353023530\n(9) 264−285610−37648+23530=15724826^4-285610-37648+23530=157248264−285610−37648+23530=157248\n\n\n","categories":["密码学"],"tags":["古典密码"]},{"title":"实验五","url":"/%E5%8C%BA%E5%9D%97%E9%93%BE/20373540-%E9%99%88%E6%98%A5%E8%95%8A-%E5%AE%9E%E9%AA%8C%E4%BA%94.html","content":"实验1 Solidity基础\n实验流程\n\n新建文件AnimalIncubators.sol\n建立一个基础合约 AnimalIncubators，并指定Solidity编译器版本\n创建宠物结构体与所用常量，及公共数组animals[]\n依据描述完成_createAnimal、_generateRandomDna、createRandomAnimal三个函数\n\n实验代码\npragma solidity &gt;=0.4.12 &lt;0.6.0;contract Animallncubators &#123;    uint dnaDigits = 16;    uint dnaLength = 10**16;    struct Animal &#123;        uint dna;        string name;    &#125;    Animal[] public animals;    event NewAnimal(uint AnimalId, string name, uint dna);    function _createAnimal(string _name, uint _dna) private &#123;        animals.push(Animal(_dna, _name));        uint _animalId = animals.length - 1;        NewAnimal(_animalId, _name, _dna);    &#125;    function _generateRandomDna(string _str) private view returns (uint)&#123;        uint rand = uint(keccak256(_str));        return rand % dnaLength;    &#125;    function createRandomAnimal(string _name) public &#123;        uint randDna = _generateRandomDna(_name);        _createAnimal(_name, randDna);    &#125;&#125;\n实验效果\n如图部署合约后创建三个分别叫Drogon、Rheagal、Viserion的宠物\n\n\n\n实验二 Solidity进阶——宠物成长系统\n实验流程\n\n创建两个映射 AnimalToOwner、ownerAnimalCount记录宠物拥有者的地址和某地址所拥有宠物的数量。\n修改_createAnimal函数来使用映射，得到新宠物后更新映射\n修改createRandomAnimal函数，使得每个用户只能调用该函数一次\n完成AnimalFeeding合约，增加进食和成长功能： 当一个宠物进食后，它自身的DNA将与食物的DNA结合在一起，形成一个新的宠物DNA\n\n实验代码\nAnimalIncubators2.sol\npragma solidity &gt;=0.4.12 &lt;0.6.0;contract Animallncubators &#123;    uint dnaDigits = 16;    uint dnaLength = 10**16;    struct Animal &#123;        uint dna;        string name;    &#125;    Animal[] public animals;    event NewAnimal(uint AnimalId, string name, uint dna);        mapping(uint=&gt;address) AnimalToOwner;    mapping(address=&gt;uint) ownerAnimalCount;        function _createAnimal(string _name, uint _dna) internal &#123;        animals.push(Animal(_dna, _name));        uint _animalId = animals.length - 1;        AnimalToOwner[_animalId]=msg.sender;        ownerAnimalCount[msg.sender]+=1;        NewAnimal(_animalId, _name, _dna);    &#125;    function _generateRandomDna(string _str) private view returns (uint)&#123;        uint rand = uint(keccak256(_str));        return rand % dnaLength;    &#125;        function createRandomAnimal(string _name) public &#123;        require(ownerAnimalCount[msg.sender]==0);                uint randDna = _generateRandomDna(_name);        _createAnimal(_name, randDna);    &#125;&#125;\nAnimalFeeding.sol\npragma solidity &gt;=0.4.12 &lt;0.6.0;import &quot;./AnimalIncubators2.sol&quot;;contract AnimalFeeding is Animallncubators&#123;    function feedAndGrow(uint _AnimalId,uint _targetDna) internal &#123;        require (keccak256(AnimalToOwner[_AnimalId])==keccak256(msg.sender));        Animal storage myAnimal=animals[_AnimalId];        uint _tDna=_targetDna%dnaDigits;        uint _newDna=uint((myAnimal.dna+_tDna)/2);        _newDna=(_newDna/100)*100+99;        _createAnimal(&quot;No-one&quot;,_newDna);        &#125;        function _catchFood(uint _name) internal pure returns (uint) &#123;      uint rand = uint(keccak256(_name));      return rand;    &#125;    function feedOnFood(uint _AnimalId,uint _FoodId) public&#123;        uint _FoodDna=_catchFood(_FoodId);        feedAndGrow(_AnimalId,_FoodDna);    &#125;&#125;\n实验效果\n首先生成一个宠物\n\n在同一地址下生成第二只宠物报错\n\n在其他地址下生成另外两只宠物\n给Drogon喂食，产生了No-one\n\n实验三 Solidity高阶理论\n实验流程\n\n创建 ownable.sol，并在createRandomAnimal函数中添加onlyOwner\n更新宠物结构的属性，新添level readyTime\n修改feedAndGrow函数实现冷却效果\n完成changeName  changeDna getAnimalsByOwner 函数\n\n实验代码\nAnimalIncubators3.sol\npragma solidity &gt;=0.4.12 &lt;0.6.0;import &quot;./ownable.sol&quot;;contract Animallncubators is Ownable &#123;    uint dnaDigits = 16;    uint dnaLength = 10**16;    struct Animal &#123;        uint dna;        string name;        uint32 level;        uint32 readyTime;    &#125;    uint32 cooldownTime = 60;        Animal[] public animals;    event NewAnimal(uint AnimalId, string name, uint dna);        mapping(uint=&gt;address) AnimalToOwner;    mapping(address=&gt;uint) ownerAnimalCount;        function _createAnimal(string _name, uint _dna) internal &#123;        animals.push(Animal(_dna, _name,0,uint32(now)));        uint _animalId = animals.length - 1;        AnimalToOwner[_animalId]=msg.sender;        ownerAnimalCount[msg.sender]+=1;        NewAnimal(_animalId, _name, _dna);    &#125;    function _generateRandomDna(string _str) private view returns (uint)&#123;        uint rand = uint(keccak256(_str));        return rand % dnaLength;    &#125;        function createRandomAnimal(string _name) public &#123;        require(ownerAnimalCount[msg.sender]==0);                uint randDna = _generateRandomDna(_name);        _createAnimal(_name, randDna);    &#125;&#125;\nAnimalFeeding.sol\npragma solidity &gt;=0.4.12 &lt;0.6.0;import &quot;./AnimalIncubators3.sol&quot;;contract AnimalFeeding is Animallncubators&#123;    function feedAndGrow(uint _AnimalId,uint _targetDna) internal &#123;        require (keccak256(AnimalToOwner[_AnimalId])==keccak256(msg.sender));        Animal storage myAnimal=animals[_AnimalId];                require(now&gt;=myAnimal.readyTime);                uint _tDna=_targetDna%dnaDigits;        uint _newDna=uint((myAnimal.dna+_tDna)/2);        _newDna=(_newDna/100)*100+99;        _createAnimal(&quot;No-one&quot;,_newDna);                myAnimal.readyTime=uint32(now)+cooldownTime;        &#125;        function _catchFood(uint _name) internal pure returns (uint) &#123;      uint rand = uint(keccak256(_name));      return rand;    &#125;    function feedOnFood(uint _AnimalId,uint _FoodId) public&#123;        uint _FoodDna=_catchFood(_FoodId);        feedAndGrow(_AnimalId,_FoodDna);    &#125;&#125;\nAnimalHelper.sol\npragma solidity &gt;=0.4.12 &lt;0.6.0;import &quot;./AnimalFeeding.sol&quot;;contract AnimalHelper is AnimalFeeding&#123;    modifier aboveLevel (uint _level,uint _AnimalId)&#123;        require(animals[_AnimalId].level&gt;=_level);        _;    &#125;        function changeName(uint _AnimalId,string _newName) external aboveLevel(2,_AnimalId)&#123;        require(keccak256(msg.sender)==keccak256(AnimalToOwner[_AnimalId]));        animals[_AnimalId].name=_newName;    &#125;        function changeDna(uint _AnimalId,uint _newDna) external aboveLevel(20,_AnimalId)&#123;        require(keccak256(msg.sender)==keccak256(AnimalToOwner[_AnimalId]));        animals[_AnimalId].dna=_newDna;    &#125;        function getAnimalsByOwner(address _owner)external view returns(uint[])&#123;        uint [] memory result=new uint[](ownerAnimalCount[_owner]);        uint count=0;        for(uint i=0;i&lt;animals.length;i++)&#123;            if(keccak256(AnimalToOwner[i])==keccak256(_owner))&#123;                result[count]=i;                count+=1;            &#125;        &#125;                return result;    &#125;&#125;\n实验效果\nonlyOwner\n\n新建一个小动物喂食\n\n再喂一次冷却还没到，报错\n\n再给1号喂\n\n这时候总共有0，1，2三只\n\n看一下getAnimalsByOwner函数效果\n\n","categories":["区块链"],"tags":["区块链实验"]},{"title":"实验六 简单Dapp的开发","url":"/%E5%8C%BA%E5%9D%97%E9%93%BE/20373540-%E9%99%88%E6%98%A5%E8%95%8A-%E5%AE%9E%E9%AA%8C%E5%85%AD.html","content":"实验1 会议报名登记系统的基本功能与实现\n实验流程\n\n系统功能要求：\n合约参与方包含一个管理员以及其余参与者，管理员可以发起不止一个会议，并指定会议信息以及总人数。\n参与者首先需要进行注册，将个人基本信息与以太坊地址相关联，并存储在合约上。\n之后可进行报名，或委托他人为自己报名。\n当会议报名人满时，该会议将不再可报名。\n当合约内某些数据发生变化时，应能够触发事件（event）使前端重新获取并渲染数据，例如当某个会议报名人满时，应触发相应事件使前端及时更新可报名会议列表。\n\n按功能要求与模板文件补全代码中的委托函数及为受托者报名函数。\n在 delegate函数中建立受托人到其委托人的一个映射，然后在enrollFor函数中实现受托人为委托人报名功能，首先由username找到受托人，后续报名流程仿写enroll,更换报名对象即可，该部分代码如下：\nfunction delegate(address addr) public&#123;\t\ttrustees[addr].push(participants[msg.sender]);\t&#125;\tfunction enrollFor(string memory username,string memory title) public returns(string memory)&#123;\t\tuint index = 0;\t\tfor (uint i = 0; i &lt; trustees[msg.sender].length; i++) &#123;\t\t\tif (keccak256(bytes(trustees[msg.sender][i].name)) == keccak256(bytes(username))) &#123;\t\t\t\tindex = i;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tfor (uint i = 0; i &lt; conferences.length; i++)&#123;\t\t\tif (keccak256(bytes(conferences[i].title)) == keccak256(bytes(title)))&#123;\t\t\t\trequire(conferences[i].current&lt;conferences[i].max,&quot;Enrolled full&quot;);\t\t\t\tconferences[i].current = conferences[i].current+1;\t\t\t\tif(conferences[i].current==conferences[i].max)&#123;\t\t\t\t\temit ConferenceExpire(title);\t\t\t\t&#125;\t\t\t\ttrustees[msg.sender][index].confs.push(title);\t\t\t&#125;\t\t&#125;\t\tuint len = trustees[msg.sender][index].confs.length;\t\trequire(len&gt;0,&quot;Conference does not exist&quot;);\t\treturn trustees[msg.sender][index].confs[len-1];\t&#125;\n练习1\n\n\n应在合约的哪个函数指定管理员身份？如何指定？\n在合约的构造函数中指定，用address public admin指定admin为管理员\n\n\n在发起新会议时，如何确定发起者是否为管理员？简述require()、assert()、revert()的区别。\n判别语句：require(msg.sender==admin,&quot;permission denied&quot;);\n如下三个语句与if(msg.sender != owner) &#123; throw; &#125;效果等价\nif(msg.sender != owner) &#123; revert(); &#125; assert(msg.sender == owner); require(msg.sender == owner);\nrevert()处理与require()同样的类型，但是需要更复杂处理逻辑的场景，二者都会将剩余gas费返还给调用者，而assert()不返还gas费，所以一般很少用assert()\n\n\n简述合约中用memory和storage声明变量的区别。\nStorage 变量是指永久存储在区块链中的变量。Memory变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。\n状态变量（在函数之外声明的变量）默认为storage形式，并永久写入区块链；而在函数内部声明的变量默认是memory型的，它们函数调用结束后消失。\n\n\n\n实验2 学习用Truffle组件部署和测试合约\n安装Truffle和Ganache\n按照教程按照即可\n为合约编写测试文件\npragma solidity &gt;=0.4.25 &lt;0.7.0;import &quot;truffle/Assert.sol&quot;;import &quot;truffle/DeployedAddresses.sol&quot;;import &quot;../contracts/Enrollment.sol&quot;;contract TestEnrollment&#123;    //测试注册后，是否返回正确注册信息（仅测试name即可）    function testSignUp() public &#123;        Enrollment en = new Enrollment();        (string memory name,) = en.signUp(&quot;alice&quot;,&quot;male&quot;);        (string memory expected_name,) = (&quot;alice&quot;,&quot;male&quot;);        Assert.equal(name,expected_name,&quot;signup failed&quot;);    &#125;    //测试管理员添加新会议是否成功    function testNewConf() public&#123;        Enrollment enroll = new Enrollment();        string memory expected = &quot;conf1&quot;;        Assert.equal(enroll.newConference(&quot;conf1&quot;,&quot;beijing&quot;,30),expected,&quot;new conference failed&quot;);    &#125;    //请测试enroll函数，确保当用户报名后，其已报名会议列表中有该会议。提示：不要忘记先由管理员创建会议。    function testEnroll() public&#123;        Enrollment en = new Enrollment();        string memory expected=&quot;conf1&quot;;        en.newConference(&quot;conf1&quot;,&quot;beijing&quot;,30);        Assert.equal(en.enroll(&quot;conf1&quot;),expected,&quot;Enrolled full&quot;);    &#125;&#125;\n进行测试truffle test\n\n用Ganache搭建私链\n测试后重新搭建一条私链\n\n进行合约部署truffle migrate，成功部署\n\n合约部署后的记录\n\n\n\n\n合约部署的主要流程包括以下4个步骤：\n（1）启动一个以太坊节点\n（2）编写智能合约\n（3）编写后的智能合约经以太坊虚拟机的编译，成为计算机可运行的字节码\n（4）合约发起用户将编译好的字节码文件通过发起交易的形式广播到区块链网络中，由矿工挖矿确认后即可将智能合约存入区块链中，并得到智能合约所在地址及调用合约所需接口\n在节点触发智能合约条件需要使用合约时，区块链将调取智能合约字节码在本地运行，然后将运行结果再保存入区块链账本中。\n另外，用户还可以通过web3接口调用智能合约，构建与之交互的Web应用，该应用由于完全构建于区块链之上，不需要第三方中介来提供服务，被称为去中心化应用（DAPP）。\n\n实验3 利用Web3.js实现合约与前端的结合\n配置Metamask\n首先按照指导书配置Metamask\n\n在前端项目文件中配置合约信息\n配置src/contracts/contract.js中的abi和合约地址\n完成组件代码中交互代码\n仿照SignUp完成其他组件的交互代码\ndelegate\nsubmit(address) &#123;   //调用合约   contract.methods.delegate(address)    .send(&#123;from:window.web3.eth.accounts[0]&#125;,function(err,res)&#123;console.log(res)&#125;)  //function中的res为方法返回值   .then((res)=&gt;console.log(res)); //该res为交易执行完后的具体交易信息，如TxHash等\nenrollFor\nsubmit(username,title) &#123;      //在此调用合约      contract.methods.enrollFor(username,title) //输入参数      .send(&#123;from:window.web3.eth.accounts[0]&#125;,function(err,res)&#123;console.log(res)&#125;)  //function中的res为方法返回值      .then(); //该res为交易执行完后的具体交易信息，如TxHash等\nmyConf\ncomponentDidMount()&#123;    //学习conflist/index.js该位置代码进行实现。    contract.methods.queryMyConf()    .call(&#123;from:window.web3.eth.accounts[0]&#125;,(err,res)=&gt;&#123;        //将返回的数组依次压入data中        this.setState(&#123;loading: true&#125;);        if(res != null)&#123;            for(var i=0;i&lt;res.length;i=i+1)&#123;                data.push(&#123;&#x27;title&#x27;: res[i]&#125;);            &#125;        &#125;        else&#123;            data.push(&#123;&#x27;title&#x27;: &#x27;no&#x27;&#125;);        &#125;    &#125;)    .then(()=&gt;&#123;        //更新状态，使页面数据重新渲染        this.setState(&#123;loading: false&#125;);    &#125;);  &#125;\n运行效果\nnpm install和npm start后，前端出现：\n\n绑定两个账户\n\n注册用户\n\n报名会议并支付花费后\n\n为usr2报名会议\n\n上课检查时候似乎是myconf写的有问题。。前端刷新不出来\n","categories":["区块链"],"tags":["区块链实验"]},{"title":"实验四","url":"/%E5%8C%BA%E5%9D%97%E9%93%BE/20373540-%E9%99%88%E6%98%A5%E8%95%8A-%E5%AE%9E%E9%AA%8C%E5%9B%9B.html","content":"实验1\n1）\n在[网站](Block #364292: 000000000000000003dd2fdbb484d6d9c349d644d8bbb3cbfa5e67f639a465fe · Bitcoin Explorer - Blockstream.info](https://blockstream.info/block/000000000000000003dd2fdbb484d6d9c349d644d8bbb3cbfa5e67f639a465fe?expand))中获得了如下信息：\n\n\n分析该区块的两个交易，第二个交易每次额度都是0.00001BTC，总共进行了5569次，这种价格极小数量极多的交易类似于对服务器进行了DDOS攻击，区块链系统设计时没有考虑这种情况，这样的交易对服务器运行效率有较大影响\n2）\n\n访问https://btc.com/stats/diff ，可以看到\n\n难度调整间隔是4天3小时\n难度变化趋势整体上升，带来的影响是计算区块越来越困难，需要消耗更多算力\n平均算力计算：难度除以平均出块时间\n\n3）\n调用API：\nPS C:\\Users\\lenovo&gt; curl https://blockstream.info/api/mempool\n\na. 分析content中内容，待验证的交易数目为4246个，数据量为1452042，大约1452042/1024/1024=1.4个区块可以处理\n**b.**高度在9991-10000 间区块内包含的总交易数目为10个\n\n实验2\nOP_3DUP OP_ADD OP_PUSHNUM_9 OP_EQUALVERIFY OP_ADD OP_PUSHNUM_7  OP_EQUALVERIFY OP_ADD OP_PUSHNUM_8 OP_EQUALVERIFY OP_PUSHNUM_1\n\n首先栈中有x,y,z,OP_3DUP复制栈,栈中元素变更为x,y,z,x,y,z\nOP_ADD,栈中前两个元素相加,栈顶变更为y+z\nOP_PUSHNUM_9 OP_EQUALVERIFY ,栈中放入9,比较y+z与9,若要成功解锁需满足y+z=9.\n之后步骤类似,依次得到解锁条件z+x=7,x+y=8\n解方程得到x=3,y=5,z=4\n\n解锁脚本为:\nOP_PUSHNUM_3 OP_PUSHNUM_5 OP_PUSHNUM_4\n脚本转化工具\n\n最终命令为\nOP_PUSHNUM_3 OP_PUSHNUM_5 OP_PUSHNUM_4 OP_PUSHBYTES  6f938893889388\n实验3\n区块详细\n\n探究ERC代币合约\n\n在 events 一栏，可以看到该合约最近的状态变动，触发改动的事务地址以及事务所 调用的具体方法：\n\n点击具体的事务地址可以获得关于该次状态变动更加详细的信息。\n\n智能合约定义为一段部署在evm虚拟机中的代码，无法自动执行，需要人为的触发才能执行，每执行一次需要发起这次执行的账户扣除对应的gas作为手续费， 智能合约与平时的代码的主要区别就是运行在一个以太坊这样的分布式平台上。\n实验4\n正则匹配相应要求\n\n实验5\n脑钱包\n\n纸钱包\n\n普通钱包\n\n拓展实验3：藏头诗\n要实现示例的样子在于两点\n\nvanitygen.exe的正则表达式生成指定内容的地址\n定位每行输入的位置， 下次位置加一\n\n使用python实现，实现代码为：\nimport osimport retarget = &#x27;experience&#x27;for i, c in enumerate(target):    pattern = &#x27;^.&#123;%d&#125;%c.*$&#x27; % (i + 1, c)    p = os.popen(&#x27;.\\\\vanitygen.exe -r &quot;%s&quot;&#x27; % (pattern))    res = re.search(r&#x27;Address: (.*)&#x27;, p.read())    print(res[1])\n效果：\n\n","categories":["区块链"],"tags":["XuperChain"]},{"title":"区块链原理与技术笔记","url":"/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.html","content":"区块链密码学基础\n杂凑函数\n关于单向性的描述：\n\n任给y，由y=H(x)计算x困难\n\n不严谨，因为xxx的选择会出现特殊情况: H(1),H(0)H(1),H(0)H(1),H(0)等, 严格定义为\nPr[x←XR,y←H(x),x′←A(y):H(x′)=y]≤neg(n)Pr[x\\leftarrow X_R,y\\leftarrow H(x),x&#x27;\\leftarrow  A(y):H(x&#x27;)=y] \\leq neg(n)\nPr[x←XR​,y←H(x),x′←A(y):H(x′)=y]≤neg(n)\n就是说Challenger在XRX_RXR​集合中均匀随机的选择xxx,计算H(x)=yH(x)=yH(x)=y,敌手Adversary由yyy计算出x′x&#x27;x′,H(x′)=yH(x&#x27;)=yH(x′)=y的概率极小.\n零知识证明\n\n零知识证明指证明者P能在不向验证者V提供任何有用信息的情况下，使验证者相信某个论断是正确的。\n\n数学表示\n证明者P要证明的关系通常表示为一种NP关系L，对于某一字符串xxx,证明者P知道对应的证据www,使得x∈Lx\\in Lx∈L可以被公开验证.\n零知识证明应满足的三点性质:\n\n完备性(V无法欺骗P) 诚实的证明者P和验证者V,如果x∈Lx\\in Lx∈L且www是其证据,则验证者总会接受证明者提供的证明\n可靠性(P无法欺骗V) x∉Lx\\notin Lx∈/L或者P不知道www,P就不能找到一个诚实验证者接受他的证明\n零知识性 V无法获得任何额外的信息\n\n","categories":["区块链"]},{"title":"区块链实验","url":"/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%9E%E9%AA%8C.html","content":"本学期一门实验课，以此记录\nweek1\n实验1  入门练习\n实验1要求三个不同正整数的最小公倍数\n实验流程\n\n\n辗转相除法构造求解最大公约数的函数\n\n\n最小公倍数即乘积除以最大公约数\n\n\n先求任意两数的最小公倍数再与第三个数求最小公倍数\n\n\n实验结果\n\n\n实验代码\npackage mainimport (\t&quot;fmt&quot;)func gcd(x, y int) int &#123;\ttmp := x % y\tif tmp &gt; 0 &#123;\t\treturn gcd(y, tmp)\t&#125; else &#123;\t\treturn y\t&#125;&#125;func lcm(x, y int) int &#123;\treturn x * y / gcd(x, y)&#125;func main() &#123;\tvar a int\tvar b int\tvar c int\tfmt.Println(&quot;Please input three numbers:&quot;)\tfmt.Scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c)\tfmt.Println(&quot; lowest common multiple = &quot;, lcm(lcm(a, b), c))&#125;\n实验2  比特币测试网地址的生成\n实验流程\n\n\n\n调用库对输入公钥进行HASH160，即RIPEMD160(SHA256(Public Key))\n\n\n将第一步结果与Version byte拼接\n\n\n将第二步结果进行HASH256，即进行两次SHA256，取前4字节作为Checksum\n\n\n将二三步结果拼接进行Base58编码得到地址\n\n\n实验结果\n\n实验代码\npackage mainimport (\t&quot;base58&quot;\t&quot;crypto/sha256&quot;\t&quot;encoding/hex&quot;\t&quot;fmt&quot;\t&quot;golang.org/x/crypto/ripemd160&quot;)const VERSION = byte(0x6f)const CHECKSUM_LENGTH = 4func GetAddress(PublicKey []byte) string &#123;\tFingerprint := HASH160(PublicKey)\taddVersion := append([]byte&#123;VERSION&#125;, Fingerprint[:]...)\tChecksum := HASH256(addVersion)\tfinalHash := append(addVersion, Checksum...)\tmyAlphabet := base58.NewAlphabet(&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;)\taddress := base58.Encode(finalHash, myAlphabet)\treturn address&#125;func HASH160(publicKey []byte) []byte &#123;\tsha256PK := sha256.Sum256(publicKey)\tr := ripemd160.New()\tr.Write(sha256PK[:])\tFingerprint := r.Sum(nil)\treturn Fingerprint&#125;func HASH256(addVersion []byte) []byte &#123;\taddVersion1 := sha256.Sum256(addVersion)\taddVersion2 := sha256.Sum256(addVersion1[:])\tChecksum := addVersion2[:CHECKSUM_LENGTH]\treturn Checksum&#125;func main() &#123;\tpk_1, _ := hex.DecodeString(&quot;02b1ebcdbac723f7444fdfb8e83b13bd14fe679c59673a519df6a1038c07b719c6&quot;)\tpk_2, _ := hex.DecodeString(&quot;036e69a3e7c303935403d5b96c47b7c4fa8a80ca569735284a91d930f0f49afa86&quot;)\tBitcoinAddress_1 := GetAddress(pk_1)\tBitcoinAddress_2 := GetAddress(pk_2)\tfmt.Println(&quot;pk_1:&quot;, BitcoinAddress_1)\tfmt.Println(&quot;pk_2:&quot;, BitcoinAddress_2)&#125;\n调库颇费周折，要注意把第三方库装到GOROOT或GOPATH所在路径下，一般推荐是后者\n实验3 Merkle Tree\n实验流程\n\n\n\n定义结构体 MerkleNode 作为节点\ntype MerkleNode struct &#123;\tleft  *MerkleNode\tright *MerkleNode\tData  []byte\tindex int&#125;\n\n\n初始化16个叶子节点，Data为对应的字符串，左右子节点都为空，索引依次赋值\n\n\n从下往上逐层构建树，先把相邻两个叶子节点合为子树，保存子树节点\n\n\n处理完叶子层再对子树结点层进行合并，最后合并到根节点，完成树的构造\n\n\n快速定位流程：\n\n从根节点的hash值开始比对，当根节点hash不同，叶节点有一处变动时有且只有一条路径上所有hash值都不同\n两树左枝相同时就转向右枝，右枝相同时就转向左枝\n\n\n\n实验结果\n\n实验代码\npackage mainimport (\t&quot;bytes&quot;\t&quot;crypto/sha256&quot;\t&quot;fmt&quot;\t// &quot;github.com/pochard/commons/randstr&quot;)func min(a int, b int) int &#123;\tif a &gt; b &#123;\t\treturn b\t&#125;\treturn a&#125;// 结点type MerkleNode struct &#123;\tleft  *MerkleNode\tright *MerkleNode\tData  []byte\tindex int&#125;func NewMerkleNode(left, right *MerkleNode, data []byte) *MerkleNode &#123;\tmNode := MerkleNode&#123;&#125;\tif left == nil &amp;&amp; right == nil &#123;\t\thash := sha256.Sum256(data)\t\tmNode.Data = hash[:]\t&#125; else &#123;\t\tpreHashes := append(left.Data, right.Data...)\t\thash := sha256.Sum256(preHashes)\t\tmNode.Data = hash[:]\t&#125;\tmNode.left = left\tmNode.right = right\treturn &amp;mNode&#125;func NewMerkleTree(data []string) *MerkleNode &#123;\tvar nodes []MerkleNode\t// 构建叶子节点\tfor i, datum := range data &#123;\t\tnode := NewMerkleNode(nil, nil, []byte(datum))\t\tnode.index = i\t\tnodes = append(nodes, *node)\t&#125;\tj := 0\tfor nSize := len(data); nSize &gt; 1; nSize = (nSize + 1) / 2 &#123;\t\tfor i := 0; i &lt; nSize; i += 2 &#123;\t\t\ti2 := min(i+1, nSize-1)\t\t\tnode := NewMerkleNode(&amp;nodes[j+i], &amp;nodes[j+i2], nil)\t\t\tnodes = append(nodes, *node)\t\t&#125;\t\tj += nSize\t&#125;\treturn &amp;nodes[len(nodes)-1]&#125;func compareMerkleTree(mTree1 *MerkleNode, mTree2 *MerkleNode) int &#123;\tif bytes.Equal(mTree1.Data, mTree2.Data) &#123;\t\treturn -1\t&#125; else &#123;\t\tfor mTree1.left != nil &#123;\t\t\tif bytes.Equal(mTree1.left.Data, mTree2.left.Data) &#123;\t\t\t\tmTree1 = mTree1.right\t\t\t\tmTree2 = mTree2.right\t\t\t&#125; else &#123;\t\t\t\tmTree1 = mTree1.left\t\t\t\tmTree2 = mTree2.left\t\t\t&#125;\t\t&#125;\t&#125;\treturn mTree1.index&#125;func main() &#123;\tdata1 := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;#&quot;&#125;\tmTree1 := NewMerkleTree(data1)\tfmt.Printf(&quot;The root Hash of MerkleTree1 is %x\\n&quot;, mTree1.Data)\tdata2 := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;-&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;#&quot;&#125;\tmTree2 := NewMerkleTree(data2)\tfmt.Printf(&quot;The root Hash of MerkleTree2 is %x\\n&quot;, mTree2.Data)\tif compareMerkleTree(mTree1, mTree2) == -1 &#123;\t\tfmt.Println(&quot;They are same&quot;)\t&#125; else &#123;\t\tfmt.Println(&quot;They are different at &quot;, compareMerkleTree(mTree1, mTree2))\t&#125;&#125;\n这个实验重点就是把树构建出来，然后定位时从根节点开始直接比就可以，熟悉语言特性的话还是蛮简单的，（菜狗作者还没学会go硬着头皮写了好久）\n拓展实验\n是一个生成挖比特币公私钥的实验，后面再看\nweek2\n实验一 构建区块\n实验要求：\n\n将空缺字段补充完整\n实现对Block的Hash计算\n\n实验流程\n\n\n区块链的基本构成单位是区块，而区块又分为区块头和区块体两部分，实现的简单区块包括字段：\n\n\n\n字段\n解释\n数据类型\n\n\n\n\nTime\n当前时间戳，也就是区块创建的时间\nint64\n\n\nPrevHash\n前一个块的哈希，即父哈希\n[]byte\n\n\nHash\n当前块的哈希\n[]byte\n\n\nData\n区块存储的实际有效信息，也就是交易\n[]byte\n\n\n\n故补全结构体为：\ntype Block struct &#123;\tTime     int64\tData     []byte\tPrevHash []byte\tHash     []byte&#125;\n\n\n实验一要求对Block的Hash计算方法为：Hash=SHA256(PrevHash + Time+ Data)，直接实现即可\n\n\n实验结果\n\n实验代码\npackage mainimport (\t&quot;crypto/sha256&quot;\t&quot;encoding/binary&quot;\t&quot;time&quot;)type Block struct &#123;\tTime     int64\tData     []byte\tPrevHash []byte\tHash     []byte&#125;func NewBlock(data string, prevHash []byte) *Block &#123;\tblock := &amp;Block&#123;time.Now().Unix(), []byte(data), prevHash, []byte&#123;&#125;&#125;\tblock.SetHash()\treturn block&#125;func (b *Block) SetHash() &#123;\t//为Block生成hash，使用sha256.Sum256(data []byte)函数\tHash := sha256.Sum256(append(append(b.PrevHash, Int64ToBytes(b.Time)...), b.Data...))\tb.Hash = Hash[:]&#125;func Int64ToBytes(i int64) []byte &#123;\tvar buf = make([]byte, 8)\tbinary.BigEndian.PutUint64(buf, uint64(i))\treturn buf&#125;\n实验二 链接区块成链\n实验要求：\n\n生成创世区块 NewGenesisBlock()\n添加新区块 Blockchain.AddBlock()\n\n实验流程\n\n生成创世区块 NewGenesisBlock()，即调用NewBlock(),Data初始化为Genesis Block，Hash值置为空\n添加新区块 Blockchain.AddBlock()，维护一个区块数组blocks作为区块链，将传入的Data与前一个区块的hash来构建新区块，然后把新区块放入数组中。\n\n实验结果\n\n实验代码\npackage maintype Blockchain struct &#123;\tblocks []*Block&#125;func (bc *Blockchain) AddBlock(data string) &#123;\t//可能用到的函数：\t//\tlen(array)：获取数组长度\t//\tappend(array,b):将元素b添加至数组array末尾\tHash := bc.blocks[len(bc.blocks)-1].Hash\tblock := NewBlock(data, Hash)\tbc.blocks = append(bc.blocks, block)&#125;func NewGenesisBlock() *Block &#123;\t//创世区块前置哈希为空，Data为&quot;Genesis Block&quot;\treturn NewBlock(&quot;Genesis Block&quot;, []byte(&quot;&quot;))&#125;func NewBlockchain() *Blockchain &#123;\treturn &amp;Blockchain&#123;[]*Block&#123;NewGenesisBlock()&#125;&#125;&#125;\n实验三 添加工作量证明模块\n\n回答问题：工作量证明中的difficulty值的大小会怎样影响PoW计算时间？\n\n设difficulty=ddd,PoW算法要求找到的hash值前ddd比特需要满足要求,成功的概率为12d\\frac{1}{2^d}2d1​,当ddd线性增大时,计算时间指数级增大\n实验流程\n\n完善工作量证明算法，主要是Hashcash算法\n\n选择部分公开数据–在 NewProofOfWork()模块中完成\n维护一个初始值为0的计数器nonce\n首先通过prepareData()模块来准备用来Hash计算的数据\n计算完成后与目标值比较判断是否在给定范围内，是则结束，否则nonce加一继续循环\n\n\n修改Block类，将nonce添加至Block结构中，修改SetHash()函数，使其调用ProofOfWork算法获得哈希值\n完成验证函数Validate()，如区块的hash在目标范围内则返回true，否则返回false\n\n在main中增加验证部分，对每一个区块调用NewProofOfWork()算法中的Validate()方法\n\n\n\n实验结果\n\n实验代码\nproofofWork部分\npackage mainimport (\t&quot;bytes&quot;\t&quot;crypto/sha256&quot;\t&quot;fmt&quot;\t&quot;math/big&quot;)const targetBits = 4type ProofOfWork struct &#123;\tblock  *Block\ttarget *big.Int&#125;func NewProofOfWork(b *Block) *ProofOfWork &#123;\ttarget := big.NewInt(1)\ttarget.Lsh(target, uint(256-targetBits))\tpow := &amp;ProofOfWork&#123;b, target&#125;\treturn pow&#125;func (pow *ProofOfWork) prepareData(nonce int) []byte &#123;\tdata := bytes.Join(\t\t[][]byte&#123;\t\t\tpow.block.PrevHash,\t\t\tpow.block.Data,\t\t\tIntToHex(pow.block.Time),\t\t\tIntToHex(int64(targetBits)),\t\t\tIntToHex(int64(nonce)),\t\t&#125;,\t\t[]byte&#123;&#125;,\t)\treturn data&#125;func (pow *ProofOfWork) Run() (int, []byte) &#123;\tvar hashInt big.Int\tvar hash [32]byte\tnonce := 0\tfmt.Printf(&quot;Mining the block containing \\&quot;%s\\&quot;\\n&quot;, pow.block.Data)\t//Hashcash算法\tfor &#123;\t\ta := pow.prepareData(nonce)\t\thash = sha256.Sum256(a)\t\thashInt.SetBytes(hash[:])\t\tif hashInt.Cmp(pow.target) &lt; 0 &#123;\t\t\tbreak\t\t&#125;\t\tnonce += 1\t&#125;\tfmt.Printf(&quot;\\r%x&quot;, hash)\tfmt.Print(&quot;\\n\\n&quot;)\treturn nonce, hash[:]&#125;func (pow *ProofOfWork) Validate() bool &#123;\tvar hashInt big.Int\thashInt.SetBytes(pow.block.Hash)\treturn hashInt.Cmp(pow.target) &lt; 0&#125;\nblock部分\npackage mainimport (\t&quot;time&quot;)type Block struct &#123;\tTime     int64\tData     []byte\tPrevHash []byte\tHash     []byte\tNonce    int&#125;func NewBlock(data string, prevHash []byte) *Block &#123;\tblock := &amp;Block&#123;time.Now().Unix(), []byte(data), prevHash, []byte&#123;&#125;, 0&#125;\tblock.SetHash()\treturn block&#125;func (b *Block) SetHash() &#123;\tpow := NewProofOfWork(b)\tb.Nonce, b.Hash = pow.Run()&#125;\nmain部分\npackage mainimport (\t&quot;fmt&quot;\t&quot;time&quot;)func main() &#123;\tt := time.Now()\tbc := NewBlockchain()\tbc.AddBlock(&quot;Send 1 BTC to Ivan&quot;)\tbc.AddBlock(&quot;Send 2 more BTC to Ivan&quot;)\tfor _, block := range bc.blocks &#123;\t\tfmt.Printf(&quot;PrevHash: %x\\n&quot;, block.PrevHash)\t\tfmt.Printf(&quot;Data: %s\\n&quot;, block.Data)\t\tfmt.Printf(&quot;Hash: %x\\n&quot;, block.Hash)\t\tfmt.Println(&quot;Pow: &quot;, NewProofOfWork(block).Validate())\t\tfmt.Println()\t&#125;\tfmt.Println(&quot;Time using: &quot;, time.Since(t))&#125;\n","categories":["区块链"],"tags":["区块链"]},{"title":"搭建XuperChain链过程","url":"/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%90%AD%E5%BB%BAXuperChain%E9%93%BE%E8%BF%87%E7%A8%8B.html","content":"参考文档\n环境准备\n\n虚拟机Ubuntu\n配置git\nsudo apt install git\n配置golang\nsudo apt install golang-go\n检查go的环境是否配置完成可用命令\ngo version\n若出现如此标识表示成功配置\n\n\n编译XuperChain\n\n\n使用git下载源码到本地\ngit clone https://github.com/xuperchain/xuperchain.git\n\n\n编译\ncd xuperchain (总之进入xuperchain这个目录）\n直接make可能会连接失败 像这样被拒绝访问\n\n所以先执行\ngo env -w GOPROXY=https://goproxy.cn\n更改权限\nsu chmod 777 xuperchain路径\n再\nmake\n编译顺利进行\n\n\n\n跑单测测试\nmake test\n\n==上述命令均在xuperchain目录下进行==\n\n\n构建单节点xchain\ncd ./output (进入output文件）\n直接执行脚本会报错\n\n需要先执行\nsudo dpkg-reconfigure dash\n然后依次执行\nsh ./control.sh start\n./bin/xchain-cli status\n生成这样的就成功构建了\n\n\n\n构建多节点\n首先\ncd ..将目录切回上级的xuperchain\n然后再\nmake testnet\n此后顺次执行文档中的命令即可\n\n\n","categories":["区块链"],"tags":["XuperChain"]},{"title":"选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发","url":"/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%80%89%E5%81%9A%E4%B8%89%EF%BC%9A%E8%AE%A4%E8%AF%86%E5%AD%98%E5%82%A8%E7%BD%91%E7%BB%9C%EF%BC%9A%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA%20IPFS%20%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91.html","content":"实验 1 远程登录服务器\n两台服务器选择了腾讯云服务器的台Ubuntu-20.04-LTS-x64系统，默认具备SSH服务。\n本实验中使用vscode进行远程操作，打开两个终端分别登录两台远程服务器\n![image-20221027192005244](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027192005244.png)\n![image-20221027192059321](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027192059321.png)\n可以看到远程登录成功\n实验 2 依赖环境安装\n\n\n编辑器使用系统自带的nano编辑器\n\n\ngo语言安装\n执行命令\nwget -4 -c https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz\n解压到/usr/local，加入环境变量\nexport PATH=$PATH:/usr/local/go/bin\n使其生效\nsource ~/.profile\n验证\n![image-20221027192937752](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027192937752.png)\n\n\napt 安装git\n![image-20221027193017823](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027193017823.png)\n\n\n实验 3 安装 IPFS\n下载压缩包go-ipfs_v0.4.17_linux-amd64.tar.gz,通过以下命令上传到服务器\nscp /E:/go-ipfs_v0.4.17_linux-amd64.tar.gz ubuntu@serverIP:/home/ubuntu/\n传输后解压并将文件复制到/usr/bin目录下\n sudo tar -zxvf go-ipfs_v0.4.17_linux-amd64.tar.gz -C ~/IPFS/cp ~/IPFS/go-ipfs/ipfs /usr/bin\n在两个服务器中都执行该过程\n实验 4 IPFS 初始化\n在两台服务器中执行初始化命令：\nipfs init\n初始化成功\nUbuntu1\n![image-20221027195952977](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027195952977.png)\nUbuntu2\n![image-20221027200139134](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027200139134.png)\n实验 5 私有网络的共享密钥生成\n在Ubuntu1中下载工具\ngo get -u github.com/Kubuxu/go-ipfs-swarm-key-gen/ipfs-swarm-key-gen\n进入下载目录\ncd ~/go/src/github.com/Kubuxu/go-ipfs-swarm-key-gen/ipfs-swarm-key-gen\n执行如下命令，生成可执行文件 ipfs-swarm-key-gen：\ngo build\n生成key\n./ipfs-swarm-key-gen &gt; ~/.ipfs/swarm.key\n将上述生成的密钥 key 复制到 Ubuntu2 相同的目录下：\nscp ~/.ipfs/swarm.key ubuntu2@ubuntu2 IP:~/.ipfs/\n在Ubuntu2中查看\n![image-20221027200749007](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027200749007.png)\n实验 6 移除默认的 Bootstrap 节点\n在两台服务器上都进行操作：  ipfs bootstrap rm –all 移除默认节点\n实验 7 启动节点服务\n在ubuntu@VM-0-9中查看节点ID并启动节点服务\n![image-20221027202058662](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027202058662.png)\n在ubuntu@VM-0-4中添加节点ubuntu@VM-0-9并启动节点服务\n![image-20221027202149402](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027202149402.png)\n这里使用的连接ip为腾讯云内网ip，固定不变，方便管理\n实验 8 测试数据抓包\n(1) 通过 IPFS 命令与网络交互，完成以下任务。\n① 查看引导节点列表，并查看已连接的其他 IPFS 节点。\n在ubuntu@VM-0-4中用ipfs bootstrap list命令查看引导节点\n![image-20221027202846482](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027202846482.png)\n使用 ipfs swarm peers 查看连接的节点\n![image-20221027203013314](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027203013314.png)\n![image-20221027203031756](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027203031756.png)\n② 在本地节点添加目录，并查看本地存储的所有文件。\n查阅命令在本地对文件操作如下\n![image-20221027203612069](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027203612069.png)\n![image-20221027203624144](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027203624144.png)\n查看文件内容\n![image-20221027203721633](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027203721633.png)\n③ 在本地节点中==下载==和删除文件。\n建立文件添加到IPFS网络\n![image-20221027204209792](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027204209792.png)\n另一台服务器中，利用文件的 Hash 值，读取 ipfs.txt。\n![image-20221027204250702](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027204250702.png)\n本地下载文件\n![image-20221103144627406](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221103144627406.png)\n查看已下载的文件\n![image-20221103144911074](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221103144911074.png)\n删除文件\n![image-20221027203915859](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027203915859.png)\n(2)抓取测试的数据包。\n用Wireshark一直报错，不知道为什么，没有解决…\n用Ubuntu自带的端口监听软件TCPDump抓包：\n在ubuntu@VM-0-4执行完ipfs add后抓取到数据包\n![image-20221027204801578](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027204801578.png)\n在ubuntu@VM-0-9执行完ipfs cat hashvalue后抓取到数据包\n![image-20221027204951023](选做三：认识存储网络：手动搭建 IPFS 环境以及简单应用的开发/image-20221027204951023.png)\n","categories":["区块链"],"tags":["区块链实验"]},{"title":"实验三","url":"/%E5%8C%BA%E5%9D%97%E9%93%BE/%E9%99%88%E6%98%A5%E8%95%8A-20373540-%E5%AE%9E%E9%AA%8C%E4%B8%89.html","content":"实验 1 熟悉 Bitcoin Core 的基本配置方法\n1.1 熟悉比特币客户端的配置方法\n本实验在Linux下完成配置\n在Ubuntu中依次执行：\nmkdir /walletcd /walletwget https://bitcoincore.org/bin/bitcoin-core-0.15.2/bitcoin-0.15.2-x86_64-linux-gnu.tar.gzcd bitcoin-0.15.2/binln -s /home/skye/Desktop/wallet/bitcoin-0.15.2/bin/bitcoind /usr/bin/bitcoindln -s /home/skye/Desktop/wallet/bitcoin-0.15.2/bin/bitcoin-cli /usr/bin/bitcoin-cliln -s /home/skye/Desktop/wallet/bitcoin-0.15.2/bin/bitcoin-qt /usr/bin/bitcoin-qt\n成功安装好：\n\n在根目录下新建.bitcoin,新建bitcoin.conf文件，文件内容如下（这里是做完后续实验的截图，regtest文件夹是下一步生成的）：\n\n运行bitcoind，regtest文件夹中内容如下：\n\n打开日志文件debug.log\n2022-09-28 12:09:23 Bitcoin version v0.15.22022-09-28 12:09:23 InitParameterInteraction: parameter interaction: -whitelistforcerelay=1 -&gt; setting -whitelistrelay=12022-09-28 12:09:23 Validating signatures for all blocks.2022-09-28 12:09:23 Setting nMinimumChainWork=00000000000000000000000000000000000000000000000000000000000000002022-09-28 12:09:23 Using the &#x27;standard&#x27; SHA256 implementation2022-09-28 12:09:23 Using RdRand as an additional entropy source2022-09-28 12:09:23 Default data directory /root/.bitcoin2022-09-28 12:09:23 Using data directory /root/.bitcoin/regtest2022-09-28 12:09:23 Using config file /root/.bitcoin/bitcoin.conf2022-09-28 12:09:23 Using at most 125 automatic connections (1024 file descriptors available)2022-09-28 12:09:23 Using 16 MiB out of 32/2 requested for signature cache, able to store 524288 elements2022-09-28 12:09:23 Using 16 MiB out of 32/2 requested for script execution cache, able to store 524288 elements2022-09-28 12:09:23 Using 4 threads for script verification2022-09-28 12:09:23 scheduler thread start2022-09-28 12:09:23 HTTP: creating work queue of depth 162022-09-28 12:09:23 No rpcpassword set - using random cookie authentication2022-09-28 12:09:23 Generated RPC authentication cookie /root/.bitcoin/regtest/.cookie2022-09-28 12:09:23 HTTP: starting 4 worker threads2022-09-28 12:09:23 init message: Verifying wallet(s)...2022-09-28 12:09:23 Using BerkeleyDB version Berkeley DB 4.8.30: (April  9, 2010)2022-09-28 12:09:23 Using wallet wallet.dat2022-09-28 12:09:23 CDBEnv::Open: LogDir=/root/.bitcoin/regtest/database ErrorFile=/root/.bitcoin/regtest/db.log2022-09-28 12:09:23 Cache configuration:2022-09-28 12:09:23 * Using 2.0MiB for block index database2022-09-28 12:09:23 * Using 8.0MiB for chain state database2022-09-28 12:09:23 * Using 440.0MiB for in-memory UTXO set (plus up to 286.1MiB of unused mempool space)2022-09-28 12:09:23 init message: Loading block index...2022-09-28 12:09:23 Opening LevelDB in /root/.bitcoin/regtest/blocks/index2022-09-28 12:09:23 Opened LevelDB successfully2022-09-28 12:09:23 Using obfuscation key for /root/.bitcoin/regtest/blocks/index: 00000000000000002022-09-28 12:09:23 LoadBlockIndexDB: last block file = 02022-09-28 12:09:23 LoadBlockIndexDB: last block file info: CBlockFileInfo(blocks=0, size=0, heights=0...0, time=1970-01-01...1970-01-01)2022-09-28 12:09:23 Checking all blk files are present...2022-09-28 12:09:23 LoadBlockIndexDB: transaction index disabled2022-09-28 12:09:23 Initializing databases...a2022-09-28 12:09:23 Pre-allocating up to position 0x1000000 in blk00000.dat2022-09-28 12:09:23 Opening LevelDB in /root/.bitcoin/regtest/chainstate2022-09-28 12:09:23 Opened LevelDB successfully2022-09-28 12:09:23 Using obfuscation key for /root/.bitcoin/regtest/chainstate: 358c63173439fcc52022-09-28 12:09:23 init message: Rewinding blocks...2022-09-28 12:09:23  block index              20ms2022-09-28 12:09:23 init message: Loading wallet...2022-09-28 12:09:23 nFileVersion = 1502002022-09-28 12:09:23 Keys: 2002 plaintext, 0 encrypted, 2002 w/ metadata, 2002 total2022-09-28 12:09:23  wallet                   51ms2022-09-28 12:09:23 setKeyPool.size() = 20002022-09-28 12:09:23 mapWallet.size() = 02022-09-28 12:09:23 mapAddressBook.size() = 12022-09-28 12:09:23 UpdateTip: new best=0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206 height=0 version=0x00000001 log2_work=1 tx=1 date=&#x27;2011-02-02 23:16:42&#x27; progress=1.000000 cache=0.0MiB(0txo)2022-09-28 12:09:23 Failed to open mempool file from disk. Continuing anyway.2022-09-28 12:09:23 mapBlockIndex.size() = 12022-09-28 12:09:23 nBestHeight = 02022-09-28 12:09:23 torcontrol thread start2022-09-28 12:09:23 Bound to [::]:184442022-09-28 12:09:23 Bound to 0.0.0.0:184442022-09-28 12:09:23 init message: Loading P2P addresses...2022-09-28 12:09:23 Loaded 0 addresses from peers.dat  0ms2022-09-28 12:09:23 init message: Loading banlist...2022-09-28 12:09:23 init message: Starting network threads...2022-09-28 12:09:23 net thread start2022-09-28 12:09:23 dnsseed thread start2022-09-28 12:09:23 Loading addresses from DNS seeds (could take a while)2022-09-28 12:09:23 0 addresses found from DNS seeds2022-09-28 12:09:23 dnsseed thread exit2022-09-28 12:09:23 addcon thread start2022-09-28 12:09:23 opencon thread start2022-09-28 12:09:23 init message: Done loading2022-09-28 12:09:23 msghand thread start2022-09-28 12:10:24 Adding fixed seed nodes as DNS doesn&#x27;t seem to be available.\n\n\n测试中为存储链上交易状态初始化的数据空间是多少？\n2022-09-28 12:09:23 * Using 2.0MiB for block index database2022-09-28 12:09:23 * Using 8.0MiB for chain state database\n可以看到是8.0MIB\n\n\n初始化过程中，节点钱包密钥池最终保存了多少对密钥？\n2022-09-28 12:09:23 setKeyPool.size() = 2000\n2000对\n\n\n简述回归测试模式下，程序添加 P2P 节点的步骤\n在区块链中增加新的区块并与ip端口绑定，之后加载P2P地址，重建peers.dat和banlist.dat；启动网线程,完成加载,然后开启其他线程,寻找新鲜的更新信息,最后接受版本信息。\n\n\n1.2 学习 bitcoin.conf 的配置方法\n\n\n.bitcoin下创建alice、bob、network三个文件夹\n\n\n对应文件夹下配置bitcoin.conf文件，具体配置如下：\nregtest=1port=22222rpcport=18332addnode=127.0.0.1:22224addnode=127.0.0.1:22226rpcuser=alice# rpc访问的passwordrpcpassword=8PPL3gL3gAM967mies3E=  #设置rpc接口的访问密码\nregtest=1port=22224rpcport=18334addnode=127.0.0.1:22222addnode=127.0.0.1:22226 rpcuser=bob# rpc访问的passwordrpcpassword=8PPL3gL3gAM967mies3E=  #设置rpc接口的访问密码\nregtest=1port=22226rpcport=18336addnode=127.0.0.1:22222addnode=127.0.0.1:22224rpcuser=networkrpcpassword=8PPL3gL3gAM967mies3E=  #设置rpc接口的访问密码\n\n\n同时启动三个终端运行:\nbitcoind -datadir=/root/.bitcoin/alice\nbitcoind -datadir=/root/.bitcoin/bob\nbitcoind -datadir=/root/.bitcoin/network\n\n\n查看debug日志\n\n可以看到节点成功连接\n\n\n实验 2 掌握常用 RPC 指令，利用回归测试网络实现挖矿与交易\nlinux中命令简写：\nalias alice-d=&#x27;bitcoind -regtest -conf=/root/.bitcoin/alice/bitcoin.conf -datadir=/root/.bitcoin/alice $*&#x27;alias bob-d=&#x27;bitcoind -regtest -datadir=/root/.bitcoin/bob $*&#x27;alias network-d=&#x27;bitcoind -regtest -datadir=/root/.bitcoin/network $*&#x27;alias alice-cli=&#x27;bitcoin-cli -regtest -conf=/root/.bitcoin/alice/bitcoin.conf -datadir=/root/.bitcoin/alice $*&#x27;alias bob-cli=&#x27;bitcoin-cli -regtest -conf=/root/.bitcoin/bob/bitcoin.conf -datadir=/root/.bitcoin/bob $*&#x27;alias network-cli=&#x27;bitcoin-cli -regtest -conf=/root/.bitcoin/network/bitcoin.conf -datadir=/root/.bitcoin/network $*&#x27;alias alice-qt=bitcoin-qt -regtest -datadir=/root/.bitcoin/alice $*alias bob-qt=bitcoin-qt -regtest -datadir=/root/.bitcoin/bob $*alias network-qt=bitcoin-qt -regtest -datadir=/root/.bitcoin/network $*\n注意-conf后面对应的是刚刚配置文件的路径，要读取rpcuser rpcpassword,找不到就会报错\n同时启动四个终端：\n\n进行交易的步骤：\n\n\nalice生成余额：\nroot@skye-vm:/home/skye# alice-cli generate 150[  ....这里有150条]root@skye-vm:/home/skye# alice-cli getbalance2500.00000000\n\n\n\n生成交易，由 alice 分别支付给 bob 2.5BTC，network 1.5BTC，并使交易入块获得确认；\n分别查询network和bob的地址，支付给他们，bob再挖一块确认，最后查看余额\nroot@skye-vm:/home/skye# alice-cli getnewaddressmgQnJdZhzPw3y5jfzoibM1kMA8Rc3huyytroot@skye-vm:/home/skye# bob-cli getnewaddressmobmsBsg7NMXVRzHsisp4gtBUtorNZY1ykroot@skye-vm:/home/skye# network-cli getnewaddressmvo34utYwAKmRY2sPiwE6mc8yBPaSocUYuroot@skye-vm:/home/skye# alice-cli sendtoaddress &quot;mobmsBsg7NMXVRzHsisp4gtBUtorNZY1yk&quot; 1.56be8d1fb847daaf2f668ff41f99168173a9af8eb7ce5635e9921a6a9c7ac40d4root@skye-vm:/home/skye# alice-cli sendtoaddress &quot;mvo34utYwAKmRY2sPiwE6mc8yBPaSocUYu&quot; 2.50c691ad0b9134650eea5dd6ee20dba25c3120acc81b1b9a798522d0e4da571c9root@skye-vm:/home/skye# bob-cli generate 1[  &quot;7f3ec2a1e50f138eb8311b0dfc1d48287a64246545ad2fd2c3c17488e3fef828&quot;]root@skye-vm:/home/skye# bob-cli listaccounts&#123;  &quot;&quot;: 1.50000000&#125;root@skye-vm:/home/skye# network-cli listaccounts&#123;  &quot;&quot;: 2.50000000&#125;\n\n\n\n实验\n输入命令：\n\n可以看到两个交易的基本情况如图，包括交易id，交易序号，输出包含交易值，scrippubkey等，第一个交易数据量大小为0.10000000，第二个为0.09890000\n\n","categories":["区块链"],"tags":["区块链实验"]},{"title":"【BUAA 18级数据结构第二题】后缀表达式转中缀表达式&表达式计算","url":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90BUAA%2018%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E9%A2%98%E3%80%91%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F&%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97.html","content":"题面\n\n【问题描述】\n从控制台输入一合法的后缀表达式，其中的运算符只包括+、-、*、/，运算数都是大于等于 0 的整数（除数不为零），按要求输出计算结果，或输出计算结果和相对应的中缀表达式。输出中缀表达式时只包含最少数目的圆括号（即在生成的中缀表达式中若去掉一对括号，则其将不能够转换回输入的后缀表达式）。输出计算结果时，小数点后保留两位，例如：10/3 的结果为 3.33\n假如输入的后缀表达式为：\n100 25 + 27 25 - / 248 + 201 -\n其相对应的中缀表达式为：\n(100+25)/(27-25)+248-201\n计算结果为 109.50。\n【输入形式】\n首先从控制台输入一个合法的后缀表达式（长度不超过 200 个字符），其中的运算符、运算数之间都以一个空格分隔。然后在下一行输入一个整数 1 或 2 表示计算要求（1 表示只输出计算结果；2 表示输出对应的中缀表达式和计算结果）。\n【输出形式】\n若输入的计算要求为 1，则只将计算结果输出到控制台，小数点后保留两位；若输入的计算要求为 2，则先将后缀表达式对应的中缀表达式输出到控制台（其中添加的小括号都为英文小括号，表达式中不包含任何空白符），然后在下一行输出计算结果，小数点后保留两位。\n【样例 1 输入】\n100 25 + 27 25 - / 248 + 201 -\n1\n【样例 1 输出】\n109.50\n【样例 2 输入】\n100 25 + 27 25 - / 248 + 201 -\n2\n【样例 2 输出】\n(100+25)/(27-25)+248-201\n109.50\n【样例 1 和 2 说明】两样例输入了相同的后缀表达式。按计算要求，样例 1 只输出了计算结果；样例 2 输出了转换后的（包含最少括号的）中缀表达式和计算结果。按照后缀表达式的计算语义，当转换为中缀表达式时，前两个运算符连成的表达式100+25 和 27-25 都要加上小括号。\n【样例 3 输入】\n100 25 + 2 58 42 + * /\n2\n【样例 3 输出】\n(100+25)/(2*(58+42))\n0.63\n【样例 3 说明】按照后缀表达式的计算语义，生成中缀表达时表达式 2*(58+42)外应该加上小括号，否则两个表达式计算顺序不一致。\n后缀转中缀算法提示：\n1、每步进行后缀表达式计算时，除了要保存计算结果外，还应保存对应的（以字符串形式表示的）运算符和中缀表达式。\n2、在进行后缀表达式计算时，当前运算符的优先级大于左运算对象运算符优先级，则生成对应的中缀表达式时左运算对象对应的中缀表达式应加括号；当前运算符的优先级大于或等于右运算对象运算符优先级时，则生成对应的中缀表达式时右运算对象对应的中缀表达式应加括号。其它情况则不用加括号。\n以样例 2 为例，在进行后缀表达式计算时：\n• 第一次进行’+‘运算时，左运算对象为 100，右为 25，运算结果为 125、运算符为’+‘、对应中缀表达式为 100+25；\n• 第二次进行’-‘运算时，左运算对象为 27，右为 25，运算结果为 2、运算符为’-‘、对应中缀表达式为 27-25；\n• 第三次进行’/‘运算时，左运算对象为 125、对应运算符为’+‘、对应中缀表达式为 100+25，由于’/‘优先级高于’+‘，因此生成对应中缀表达式时 100+25应加括号；右运算对象为 2、对应运算符为’-‘、对应中缀表达式为 27-25，由于’/‘优先级高于’-‘，因此生成对应中缀表达式时 27-25 也应加括号。该步运算结果为 62.5、运算符为’/'、对应中缀表达式为(100+25)/(27-25)；\n• 以此类推\n\n思路分析\n\n首先1情况很好实现，搞一个数据栈，从头开始读表达式，因为是后缀表达式，所以可以直接莫伊。即遇到数字就压入栈，遇到运算符就将栈顶的两个数字出栈进行运算，运算结果入栈。\n情况2折磨我良久QAQ注意到算法提示中的描述，应该意识到这也是一个栈操作，区别在于栈内的元素是表达式，上述描述中左运算对象对应次栈顶元素，右运算对象对应栈顶元素，（单独的数也看作是一个表达式）每遇到运算符就将栈顶的两个元素弹出与运算符重新组合，组合结果入栈，这个过程和1是可以同步进行的。\n\n总体规划有了，我们需要考虑的细节是：\n\n怎么加括号\n怎么组合新的表达式\n\n\n加括号其实就是考虑先算谁，先算乘除再算加减肯定没问题，如果遇到优先级高一级的就直接加括号，但注意==大于或等于右运算对象运算符优先级==这一句中的等于，就是在问你从左往右算的时候先算谁（给谁加括号），优先级相等的情况有：–、++、±、**、//、*/ ，如果是前5种，那么运算顺序没有影响，所以不用加括号,而最后一种 5*6/3和(5*6)/3结果是不一样的，所以为了方便我们可以认为*的优先级低于/;\n这样只要判断表达式的运算符（表达式的运算符需要在每次组合完后更新）的优先级是否低于当前运算符，低于就加；\n组合新表达式嘛，本蒻蒟笨笨的复制粘贴了一遍，懒得动脑子了\n基于这样的考虑，就可以有这样的一个表达式栈的结构，   struct infix&#123;\tchar item[MAXSIZE*2];\tchar flag;&#125; ans_stack[MAXSIZE];\n\n\n更多细节写注释里了~\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXSIZE 205struct infix&#123;\tchar item[MAXSIZE*2];\tchar flag;&#125; ans_stack[MAXSIZE];double numSTACK[MAXSIZE];int num[MAXSIZE],cnt;\t\t/*这个num数组用来储存输入中的顺序，\t\t\t\t\t\t\t因为在表达式栈中为了简洁操作用&#x27;n&#x27;来代替数字，\t\t\t\t\t\t\t而后缀表达式转为中缀的过程中数字顺序没有变化，\t\t\t\t\t\t\t所以可以输出的时候遇到n直接从数学序列中对应输出*/char opSTACK[MAXSIZE];int numTOP,ansTop;void Init()&#123;\tnumTOP = -1;\tansTop = -1;&#125;void CAL(char op); //计算int isLowerThan(char a,char b)//判断a的优先级是否小于b&#123;//判断优先级 注意*和/\treturn ((a == &#x27;+&#x27; || a == &#x27;-&#x27;) &amp;&amp; (b == &#x27;*&#x27; || b == &#x27;/&#x27;))||(a==&#x27;*&#x27;&amp;&amp;b==&#x27;/&#x27;);&#125;void addBrackets(char flag, char s[],char c);int main()&#123;\tInit();\tchar in[300];\tchar c;\tint i, aim, now = 0, flag = 0;\tgets(in);\tscanf(&quot;%d&quot;, &amp;aim);\tfor (i = 0; in[i]; i++)\t&#123;\t\tc = in[i];\t\tif (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)\t\t&#123;//读入数字常用手段\t\t\tnow *= 10, now += c - &#x27;0&#x27;;\t\t\tflag = 1;\t\t&#125;\t\telse if (c == &#x27; &#x27;)\t\t&#123;\t\t\tif (flag)//但注意如果没读入的话now一直是0 都入栈了 会有一些离谱的输出所以要判断有没有读数字\t\t\t&#123;\tnumSTACK[++numTOP] =(double) now;\t\t\t\tans_stack[++ansTop].item[0] = &#x27;n&#x27;;//用n代替数字\t\t\t\tans_stack[ansTop].flag = &#x27;#&#x27;;//如果是单个数字作为表达式就不用加括号，直接标记\t\t\t\tnum[cnt++] = now;//作为输出的对应表\t\t\t&#125;\t\t\tnow = 0;\t\t\tflag = 0;\t\t&#125;\t\telse\t\t&#123;\t\t\t//先给左右运算对象加括号\t\t\taddBrackets(ans_stack[ansTop - 1].flag, ans_stack[ansTop - 1].item, c);\t\t\taddBrackets(ans_stack[ansTop].flag, ans_stack[ansTop].item, c);\t\t\t//然后组合，左 运算符 右连起来\t\t\tint len = strlen(ans_stack[ansTop - 1].item);\t\t\tans_stack[ansTop - 1].item[len] = c;\t\t\tlen++;\t\t\tfor (int j = 0;ans_stack[ansTop].item[j];j++)\t\t\t&#123;\t\t\t\tans_stack[ansTop - 1].item[len++] = ans_stack[ansTop].item[j];\t\t\t&#125;\t\t\tans_stack[ansTop - 1].item[len] = &#x27;\\0&#x27;;\t\t\tans_stack[ansTop - 1].flag = c;//重置当前表达式的运算符\t\t\tmemset(ans_stack[ansTop].item, &#x27;\\0&#x27;, sizeof(ans_stack[ansTop].item));\t\t\t//注意出栈一定要清空数组\t\t\tansTop--;\t\t\tCAL(c);\t\t&#125;\t&#125;\tcnt = 0;\tif (aim == 2)\t&#123;\t\tfor (int i = 0; ans_stack[0].item[i];i++)\t\t&#123;\t\t\tif(ans_stack[0].item[i]==&#x27;n&#x27;)\t\t\t\tprintf(&quot;%d&quot;, num[cnt++]);\t\t\telse\t\t\t\tprintf(&quot;%c&quot;, ans_stack[0].item[i]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;%.2lf&quot;, numSTACK[0]);\treturn 0;&#125;void addBrackets(char flag, char s[],char c)&#123;\tif(flag!=&#x27;#&#x27;&amp;&amp;isLowerThan(flag,c))\t&#123;\t\tint len = strlen(s);\t\tfor (int j = len-1; j &gt;= 0;j--)\t\t\ts[j + 1] = s[j];\t\ts[0] = &#x27;(&#x27;;\t\ts[len + 1] = &#x27;)&#x27;;\t\ts[len + 2] = &#x27;\\0&#x27;;\t&#125;\treturn;&#125;void CAL(char op)&#123;\tif (op == &#x27;*&#x27;)\t\tnumSTACK[numTOP - 1] = numSTACK[numTOP - 1] * numSTACK[numTOP];\telse if (op == &#x27;/&#x27;)\t\tnumSTACK[numTOP - 1] = numSTACK[numTOP - 1] / numSTACK[numTOP];\telse if (op == &#x27;+&#x27;)\t\tnumSTACK[numTOP - 1] = numSTACK[numTOP - 1] + numSTACK[numTOP];\telse if (op == &#x27;-&#x27;)\t\tnumSTACK[numTOP - 1] = numSTACK[numTOP - 1] - numSTACK[numTOP];\tnumTOP--;&#125;\n","categories":["数据结构"],"tags":["表达式","C语言"]},{"title":"【数据结构篇】树的遍历","url":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91%E6%A0%91%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89.html","content":"树的遍历\n前序遍历\n\n\n首先访问根节点，然后遍历左子树，最后遍历右子树\n递归写法\n  void preTravel(struct TreeNode*root)&#123;    if(root!=NULL)    &#123;        printf(&quot;%d&quot;,root-&gt;val);        travel(root-&gt;left);        travel(root-&gt;right);    &#125;&#125;\n迭代写法 (迭代就是把递归过程中调用的栈显式表达出来)\n  void preTravel(struct TreeNode*root)&#123;    struct TreeNode *stk[100];    int stk_top = -1;    while (stk_top &gt; -1 || root != NULL)     &#123;        while (root != NULL)         &#123;            printf(&quot;%d&quot;,root-&gt;val);            stk[++stk_top] = root;            root = root-&gt;left;        &#125;        root = stk[stk_top--];        root = root-&gt;right;    &#125;&#125;\n\n\n中序遍历\n\n\n先左后根最后右（==二叉搜索树中可以得到递增的有序序列==）\n递归写法\n  void inorderTravel(struct TreeNode*root)&#123;     if(root==NULL)        return;    inorderTravel(root-&gt;left);    printf(&quot;%d&quot;,root-&gt;val);    inorderTravel(root-&gt;right);&#125;\n迭代写法 (迭代就是把递归过程中调用的栈显式表达出来)\n  void inorderTravel(struct TreeNode*root)&#123;    struct TreeNode *stk[100];    int stk_top = -1;    while (stk_top &gt; -1 || root != NULL)     &#123;        while (root != NULL)         &#123;            stk[++stk_top] = root;            root = root-&gt;left;        &#125;        root = stk[stk_top--];        printf(&quot;%d&quot;,root-&gt;val);        root = root-&gt;right;    &#125;&#125;\n\n\n后序遍历\n\n\n先左后右最后根\n递归写法\n   void postTravel(struct TreeNode*root)&#123;     if(root==NULL)        return;    postTravel(root-&gt;left,a,returnSize);    printf(&quot;%d&quot;,root-&gt;val);    postTravel(root-&gt;right,a,returnSize);&#125;\n迭代写法\n  void preTravel(struct TreeNode*root)&#123;    struct TreeNode *stk[100];    struct TreeNode *prev = NULL;    int stk_top = -1;    if(root==NULL)        return;    while (stk_top &gt; -1 || root != NULL)     &#123;        while (root != NULL)         &#123;            stk[++stk_top] = root;            root = root-&gt;left;        &#125;        root=stk[stk_top--];        if (root-&gt;right == NULL || root-&gt;right == prev) &#123;            printf(&quot;%d&quot;,root-&gt;val);            prev = root;            root = NULL;        &#125;         else         &#123;            stk[top++] = root;            root = root-&gt;right;        &#125;    &#125;&#125;\n\n\n层序遍历\n\n用队列实现广度优先搜索，逐层遍历\n\n#define MAX 2000int **levelOrder(struct TreeNode*root,int *returnSize,int **returnColumnSize)&#123;//返回逐层遍历的二维数组，returnColumnSize记录每一层的大小    *returnSize=0;//层数    if(root==NULL)        return;    int**res=(int**)malloc(sizeof(int*)*MAX);//申请一个二维数组空间    struct TreeNode*Q[MAX];//队，存放所有结点    *returnColumnSize=(int*)malloc(sizeof(int)*MAX);    int flag,size,front=0,rear=0;    struct TreeNode*tmp=NULL;    Q[rear++]=root;    while(front!=rear)    &#123;//队列不空时        flag=rear;//当前层尾指针        size=0;//当前层数组大小        res[*returnSize]=(int*)malloc(sizeof(int*)*(flag-front));        while(front&lt;flag)        &#123;//处理当前层            tmp=Q[front++];            res[*returnSize][size++]=tmp-&gt;val;            //每个结点的左右孩子入队            if(p-&gt;left)                Q[rear++]=p-&gt;left;            if(p-&gt;right)                Q[rear++]=p-&gt;right;        &#125;        (*returnColumnSize)[*returnSize]=size;        returnSize++;    &#125;    return res;&#125;\n递归解决问题\n\n最大深度\n\nint maxDepth(struct TreeNode* root)&#123;     return root == NULL ? 0 :fmax(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+ 1;&#125;\n\n对称二叉树\n\nbool isMirror(struct TreeNode*p,struct TreeNode*q)&#123;//递归思想：如果对称，那每个树的右子树镜像对称另一个树的左子树    if(!p&amp;&amp;!q)        return true;    if(!p||!q)        return false;    return (p-&gt;val==q-&gt;val)&amp;&amp;(isMirror(p-&gt;left,q-&gt;right))&amp;&amp;(isMirror(p-&gt;right,q-&gt;left));&#125;bool isSymmetric(struct TreeNode* root)&#123;    return isMirror(root,root);&#125;\n\n路径总和\n\n//判断二叉树中是否有一条路径节点之和等于目标值bool hasPathSum(struct TreeNode* root, int targetSum)&#123;    if(!root)        return false;    if(!root-&gt;left&amp;&amp;!root-&gt;right)        return root-&gt;val==targetSum;    return hasPathSum(root-&gt;left,targetSum-root-&gt;val)||hasPathSum(root-&gt;right,targetSum-root-&gt;val);&#125;\n\n最近公共祖先\n\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123;    struct TreeNode* ancestor=root;    while(1)    &#123;        if(p-&gt;val&lt;ancestor-&gt;val&amp;&amp;q-&gt;val&lt;ancestor-&gt;val)            ancestor=ancestor-&gt;left;        else if(p-&gt;val&gt;ancestor-&gt;val&amp;&amp;q-&gt;val&gt;ancestor-&gt;val)            ancestor=ancestor-&gt;right;        else            break;    &#125;    return ancestor;&#125;\n\n最长路径\n\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;const int N = 100010;int e[N] , ne[N] , h[N] , idx;int f[N];//f[u]表示u到最远叶节点的距离。显然如果u是节点，则f[u]=0。int n , m , ans;void add(int a , int b)&#123;    e[idx] = b , ne[idx] = h[a] , h[a] = idx++;&#125;void dfs(int u)//求以u为根节点到叶节点的最大距离&#123;    int a = 0 , b = 0;//a记录u到最远叶节点的距离，b记录u到次远叶节点的距离    for(int i = h[u] ; ~i ; i = ne[i])    &#123;        int j = e[i];        //求子节点j到最远叶节点的距离        dfs(j);        int t = f[j] + 1;//u通过j能到的最远叶节点的距离        //更新a、b        if(t &gt;= a)            b = a , a = t;        else if(t &gt; b)            b = t;    &#125;    f[u] = a;    //最后的答案就是u所能到的最远叶节点距离和次远叶节点距离之和    ans = max(ans , a + b);&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h , -1 , sizeof h);    //电脑其实和交换机等价，所以电脑的标号从n继续往后标记即可    for(int i = 2 ; i &lt;= n + m ; i++)    &#123;        int j;        cin &gt;&gt; j;        add(j , i);//因为是自根向下DP，所以建一条边即可。    &#125;    dfs(1);    cout &lt;&lt; ans &lt;&lt; endl;&#125;\n","categories":["数据结构","树"],"tags":["C语言","数据结构","树"]},{"title":"【数据结构篇】链表","url":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91%E9%93%BE%E8%A1%A8%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89.html","content":"【数据结构篇】链表\n设计链表\n\n在链表类中实现这些功能：\n\n\n·get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\n·addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\n·addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\n·addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\n·deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\n\n代码示例如下\n\ntypedef struct MyLinkedList_t&#123;\tint val;\tstruct MyLinkedList_t *next;&#125; MyLinkedList;/** Initialize your data structure here. */MyLinkedList *myLinkedListCreate()&#123;\tMyLinkedList *obj = (MyLinkedList *)malloc(sizeof(MyLinkedList));\tobj-&gt;val = 0;\tobj-&gt;next = NULL;\treturn obj;&#125;/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */int myLinkedListGet(MyLinkedList *obj, int index)&#123;\tif (index &lt; 0 || obj-&gt;next == NULL)\t&#123;\t\treturn -1;\t&#125;\t\tint now = 0;\tMyLinkedList *listNow = obj-&gt;next;\twhile (now &lt; index)\t&#123;\t\tif (listNow == NULL)\t\t&#123;\t\t\treturn -1;\t\t&#125;\t\tlistNow = listNow-&gt;next;\t\tnow++;\t&#125;\tif (listNow != NULL)\t&#123;\t\treturn listNow-&gt;val;\t&#125;\treturn -1;&#125;/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */void myLinkedListAddAtHead(MyLinkedList *obj, int val)&#123;\tMyLinkedList *Node = (MyLinkedList *)malloc(sizeof(MyLinkedList));\tNode-&gt;val = val;\tNode-&gt;next = NULL;\tif (obj-&gt;next == NULL)\t&#123;\t\tobj-&gt;next = Node;\t\treturn;\t&#125;\telse\t&#123;\t\tNode-&gt;next = obj-&gt;next;\t\tobj-&gt;next = Node;\t&#125;&#125;/** Append a node of value val to the last element of the linked list. */void myLinkedListAddAtTail(MyLinkedList *obj, int val)&#123;\tMyLinkedList *Node = (MyLinkedList *)malloc(sizeof(MyLinkedList));\tNode-&gt;val = val;\tNode-&gt;next = NULL;\tMyLinkedList *nowList = obj;\twhile (nowList-&gt;next != NULL)\t&#123;\t\tnowList = nowList-&gt;next;\t&#125;\tnowList-&gt;next = Node;&#125;/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */void myLinkedListAddAtIndex(MyLinkedList *obj, int index, int val)&#123;\tif (index &lt;= 0)\t&#123;\t\tmyLinkedListAddAtHead(obj, val);\t&#125;\tint now = 0;\tMyLinkedList *nowList = obj-&gt;next;\twhile (nowList-&gt;next != NULL)\t&#123;\t\tif (now == index - 1)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\tnowList = nowList-&gt;next;\t\tnow++;\t&#125;\tif (index - 1 != now)\t&#123;\t\treturn;\t&#125;\tMyLinkedList *Node = (MyLinkedList *)malloc(sizeof(MyLinkedList));\tNode-&gt;val = val;\tNode-&gt;next = nowList-&gt;next;\tnowList-&gt;next = Node;&#125;/** Delete the index-th node in the linked list, if the index is valid. */void myLinkedListDeleteAtIndex(MyLinkedList *obj, int index)&#123;\tMyLinkedList *r;\tif (index &lt; 0 || obj-&gt;next == NULL)\t&#123;\t\treturn;\t&#125;\tif (index == 0)\t&#123;\t\tr = obj-&gt;next;\t\tobj-&gt;next = obj-&gt;next-&gt;next;\t\tfree(r);\t\treturn;\t&#125;\tMyLinkedList *nowList = obj-&gt;next;\tint now = 0;\twhile (nowList-&gt;next != NULL)\t&#123;\t\tif (now == index - 1)\t\t&#123;\t\t\tbreak;\t\t&#125;\t\tnowList = nowList-&gt;next;\t\tnow++;\t&#125;\tif (now == index - 1 &amp;&amp; nowList-&gt;next != NULL)\t&#123;\t\tr = nowList-&gt;next;\t\tnowList-&gt;next = nowList-&gt;next-&gt;next;\t\tfree(r);\t&#125;&#125;void myNodeFree(MyLinkedList *Node)&#123;    if (Node-&gt;next != NULL)&#123;    myNodeFree(Node-&gt;next);    Node-&gt;next = NULL;&#125;free(Node);&#125;void myLinkedListFree(MyLinkedList *obj)&#123;//从最后一个结点向前逐渐释放，这里用递归实现    myNodeFree(obj);&#125;\n环形链表\n\n可以用快慢指针判断是否有环（有环返回真，无环返回假）\n\ntypedef struct &#123;      int val;      struct ListNode *next;  &#125;ListNode;bool hasCycle(struct ListNode *head) &#123;        if(head==NULL) return false;        ListNode *f=head;        ListNode *s=head;        do&#123;            if(f-&gt;next==NULL||f-&gt;next-&gt;next==NULL) return false;            f=f-&gt;next-&gt;next;//f为走两步的快指针            s=s-&gt;next;//s为走一步的慢指针        &#125;while(f!=s);        return true;//如果有环一定能相遇    &#125;\n\n如果要返回==入环的第一个结点==呢？\n\n\n可以这样分析：\n1 慢指针走过的路程为a(头结点到环入口的距离)+b(慢指针在环内的距离)\n2 快指针走过的路程为a+b+c(相遇点到换入口的距离)+b\n3 因为快指针速度是慢指针的两倍，所以可以导出a=c\n4 所以只要再安排一个位于头结点的指针和慢指针同时出发，它们的相遇位置即为环入口\nstruct ListNode *detectCycle(struct ListNode *head) &#123;        if(head==NULL) return false;        struct ListNode *f=head;        struct ListNode *s=head;        do&#123;            if(f-&gt;next==NULL||f-&gt;next-&gt;next==NULL) return false;            f=f-&gt;next-&gt;next;//f为走两步的快指针            s=s-&gt;next;//s为走一步的慢指针        &#125;while(f!=s);       struct ListNode*p=head;       while(p!=s)       &#123;           p=p-&gt;next;           s=s-&gt;next;       &#125;        return p;&#125;\n回文链表\nstruct ListNode* reverseList(struct ListNode* head) &#123;    struct ListNode* prev = NULL;    struct ListNode* curr = head;    while (curr != NULL) &#123;        struct ListNode* nextTemp = curr-&gt;next;        curr-&gt;next = prev;        prev = curr;        curr = nextTemp;    &#125;    return prev;&#125;//反转链表struct ListNode* endOfFirstHalf(struct ListNode* head) &#123;    struct ListNode* fast = head;    struct ListNode* slow = head;    while (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;    &#125;    return slow;&#125;bool isPalindrome(struct ListNode* head) &#123;    if (head == NULL) &#123;        return true;    &#125;    // 找到前半部分链表的尾节点并反转后半部分链表    struct ListNode* firstHalfEnd = endOfFirstHalf(head);    struct ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);    // 判断是否回文    struct ListNode* p1 = head;    struct ListNode* p2 = secondHalfStart;    bool result = true;    while (result &amp;&amp; p2 != NULL) &#123;        if (p1-&gt;val != p2-&gt;val) &#123;            result = false;        &#125;        p1 = p1-&gt;next;        p2 = p2-&gt;next;    &#125;    // 还原链表并返回结果    firstHalfEnd-&gt;next = reverseList(secondHalfStart);    return result;&#125;\n持续更新中\n","categories":["数据结构","链表"],"tags":["C语言","数据结构","链表"]},{"title":"【Go学习笔记】","url":"/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","content":"Go语言基础\n常量\n设置多个常量：\nconst (    Cyan = 0    Black = 1    White = 2)\ngo语言的预定义常量：true、false、iota\niota 是一个可以被编译器修改的常量，在 const 关键字出现时被重置为 0，在下一个 const 出现之前，每出现一次 iota，其所代表的数字自动加 1。下面通过一个例子讲解 iota 的用法：\nconst (    a = iota  //a == 0    b = iota  //b ==1    c = iota  //c == 2)const d = iota //d==0,因为const的出现，iota被重置为0\n变量\n变量声明var或:=,二者只用一个\nGo 声明和初始化变量的各种方法：\nvar a intvar b stringvar c float64var d [5] int  //数组var e [] int   //数组切片var f * int    //正确var v1 int = 5 //正确var v2 = 5     //正确，编译器自动推导出V2类型v3 := 5        //正确，编译器自动推导出V3的类型\n数据类型\n整型\nGo 语言提供了 11 种整型，如下列表所示。可以通过unsafe.Sizeof(引入unsafe包)查看类型字节长度\n\n\n\n类型\n说明\n字节长度\n\n\n\n\nbyte\n等同于 uint8\n\n\n\nint\n依赖于不同平台下的实现，可以是 int32 或者 int64\n\n\n\nint8\n[-128, 127]\n1\n\n\nint16\n[-32768, 32767]\n2\n\n\nint32\n[-2147483648, 2147483647]\n4\n\n\nint64\n[-9223372036854775808, 9223372036854775807]\n8\n\n\nrune\n等同于 int32\n\n\n\nuint\n依赖于不同平台下的实现，可以是 uint32 或者 uint64\n\n\n\nuint8\n[0, 255]\n\n\n\nuint16\n[0, 65535]\n\n\n\nuint32\n[0, 4294967295]\n\n\n\nuint64\n[0, 18446744073709551615]\n\n\n\nuintptr\n一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64）\n\n\n\n\n浮点型\nGo 语言提供了两种浮点类型和两种复数类型，具体如下：\n\n\n\n类型\n说明\n\n\n\n\nfloat32\n±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数\n\n\nfloat64\n±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数\n\n\ncomplex32\n复数，实部和虚部都是 float32\n\n\ncomplex64\n复数，实部和虚部都是 float64\n\n\n\n布尔型\n\nGo 语言提供了内置的布尔值 true 和false。\n可以通过 !b 的方式反转变量 b 的真假\n布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。\n\n字符串\n字符串操作\n字符串支持以下操作：\n\n\n\n语法\n描述\n\n\n\n\ns += t\n将字符串 t 追加到 s 末尾\n\n\ns + t\n将字符串 s 和 t 级联\n\n\ns[n]\n从字符串 s 中索引位置为 n 处的原始字节\n\n\ns[n:m]\n从位置 n 到位置 m-1 处取得的字符（字节）串\n\n\ns[n:]\n从位置 n 到位置 len(s)-1 处取得的字符（字节）串\n\n\ns[:m]\n从位置 0 到位置 m-1 处取得的字符（字节）串\n\n\nlen(s)\n字符串 s 中的字节数\n\n\nlen([]rune(s))\n字符串 s 中字符的个数，可以使用更快的方法 utf8.RuneCountInString()\n\n\n[]rune(s)\n将字符串 s 转换为一个 unicode 值组成的串\n\n\nstring(chars)\nchars 类型是 []rune 或者 []int32, 将之转换为字符串\n\n\n[]byte(s)\n无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节\n\n\n\n格式化字符串\n常用的格式化指令如下：\n\n\n\n格式化指令\n含义\n\n\n\n\n%%\n% 字面量\n\n\n%b\n一个二进制整数，将一个整数格式化为二进制的表达方式\n\n\n%c\n一个 Unicode 的字符\n\n\n%d\n十进制数值\n\n\n%o\n八进制数值\n\n\n%x\n小写的十六进制数值\n\n\n%X\n大写的十六进制数值\n\n\n%U\n一个 Unicode 表示法表示的整形码值，默认是 4 个数字字符\n\n\n%s\n输出以原生的 UTF-8 字节表示的字符，如果 console 不支持 UTF-8 编码，则会输出乱码\n\n\n%q\n输出带引号的字符串及字面量，如fmt.Printf(&quot;%q\\n&quot;, &quot;hello\\n;&quot;) // prints &quot;hello\\n;&quot; \\n is escaped here\n\n\n%t\n以 true 或者 false 的方式输出布尔值\n\n\n%v\n使用默认格式输出值，或者使用类型的 String() 方法输出的自定义值，如果该方法存在的话\n\n\n%T\n输出值的类型\n\n\n\n常用的格式化指令修饰符如下：\n\n空白 如果输出的数字为负，则在其前面加上一个减号 -。如果输出的是整数，则在前面加一个空格。使用 %x 或者 %X 格式化指令输出时，会在结果之间添加一个空格。例如 fmt.Printf(&quot;% X&quot;, &quot;实&quot;) 输出 E5 AE 9E。\n#\n\n%#o 输出以 0 开始的八进制数据。\n%#x 输出以 0x 开始的十六进制数据。\n\n\n+ 让格式化指令在数值前面输出 + 号或者 - 号，为字符串输出 ASCII 字符（非 ASCII 字符会被转义），为结构体输出其字段名。\n- 让格式化指令将值向左对齐（默认值为像右对齐）。\n0 让格式指令以数字 0 而非空白进行填充。\n\n切片\n\n值传递：形参是实参的拷贝，复制一份传递\n指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作\n引用传递：形参是实参的“别名”\n\n数组是按值传递的（即是传递的副本），而切片是引用类型，传递切片的成本非常小，而且是不定长的。可以理解为go的切片和数组共用同一片底层区域，只是按照索引划分区域起了别名。\n切片语法\n创建切片的语法：\n\nmake([ ]Type, length, capacity)\nmake([ ]Type, length) ——默认切片长度和容量一致\n[ ]Type&#123;&#125;\n[ ]Type&#123;value1, value2, ..., valueN&#125;\n\npackage mainimport (    &quot;fmt&quot;)func main() &#123;\ta := [...]int&#123;1,2,3,4,5,6,7&#125; //a是一个int型数组\tfmt.Printf(&quot;len and cap of array %v is: %d and %d\\n&quot;, a, len(a), cap(a))//%v--原样输出\tfmt.Printf(&quot;item in array: %v is:&quot;, a)    for _, value := range a &#123;        fmt.Printf(&quot;% d&quot;, value)\t&#125;\t\tfmt.Println()    s1 := a[3:6]\tfmt.Printf(&quot;len and cap of slice1: %v is: %d and %d\\n&quot;, s1, len(s1), cap(s1))\t//len=3 cap=4    fmt.Printf(&quot;item in slice1: %v is:&quot;, s1)    for _, value := range s1 &#123;        fmt.Printf(&quot;% d&quot;, value)\t&#125;\t\tfmt.Println()    s1[0] = 456    fmt.Printf(&quot;item in array changed after changing slice: %v is:&quot;, s1)    for _, value := range a &#123;        fmt.Printf(&quot;% d&quot;, value)\t&#125;\t\tfmt.Println()\ts3 := s1[:cap(s1)]    fmt.Printf(&quot;len and cap of slice3: %v is: %d and %d\\n&quot;, s3, len(s3), cap(s3))\tfmt.Printf(&quot;item in slice3: %v is:&quot;, s3)\tfor _, value := range s3 &#123;        fmt.Printf(&quot;% d&quot;, value)\t&#125;\t\tfmt.Println()    s2 := make([]int, 10, 20)    s2[4] = 5    fmt.Printf(&quot;len and cap of slice2: %v is: %d and %d\\n&quot;, s2, len(s2), cap(s2))    fmt.Printf(&quot;item in slice2 %v is:&quot;, s2)    for _, value := range s2 &#123;        fmt.Printf(&quot;% d&quot;, value)    &#125;    fmt.Println()&#125;\n输出结果为：\nlen and cap of array [1 2 3 4 5 6 7] is: 7 and 7item in array: [1 2 3 4 5 6 7] is: 1 2 3 4 5 6 7len and cap of slice1: [4 5 6] is: 3 and 4item in slice1: [4 5 6] is: 4 5 6item in array changed after changing slice: [456 5 6] is: 1 2 3 456 5 6 7len and cap of slice3: [456 5 6 7] is: 4 and 4item in slice3: [456 5 6 7] is: 456 5 6 7len and cap of slice2: [0 0 0 0 5 0 0 0 0 0] is: 10 and 20item in slice2 [0 0 0 0 5 0 0 0 0 0] is: 0 0 0 0 5 0 0 0 0 0\n切片扩容\n切片通过 append 扩容时，如果切片长度小于当前的容量，那么切片不会扩容，如果追加元素后切片长度大于当前的容量时，切片就会扩容，扩容机制如下：\n\n当扩容之后的元素长度小于 1024 时会以原切片容量的 2 倍的进行扩容；\n当扩容之后的元素长度大于 1024 时会以原切片容量的 1.25 倍的进行扩容；\n\n更多扩容细节参照博客http://t.csdn.cn/zQmdq\n相关文档\n\nGo 语言官方文档\nGo 入门指南\nGo web 编程\n\nGo语言顺序编程\n流程控制\nif语句\n注意}和else要在同一行\nfor语句\nfor &#123; // 无限循环    block&#125;for booleanExpression &#123; // while循环，在Go语言中没有while关键字&#125;for index, char := range aString &#123; // 迭代字符串&#125;for item := range aChannel &#123; // 迭代通道&#125;\n跳转语句——goto\nfunc myfunc()&#123;    i := 0    THIS: //定义一个THIS标签    fmt.Println(i)    i++    if i &lt; 1 &#123;        goto THIS //跳转到THIS标签    &#125;&#125;\nswitch语句\n类型选择：\nfunc classchecker(items ...interface&#123;&#125;) &#123; // 创建一个函数，该函数可以接受任意多的任意类型的参数    for i, x := range items &#123;        switch x := x.(type) &#123; // 创建了影子变量        case bool:            fmt.Printf(&quot;param #%d is a bool, value: %t\\n&quot;, i, x)        case float64:            fmt.Printf(&quot;param #%d is a float64, value: %f\\n&quot;, i, x)        case int, int8, int16, int32, int64:            fmt.Printf(&quot;param #%d is a int, value: %d\\n&quot;, i, x)        case uint, uint8, uint16, uint32, uint64:            fmt.Printf(&quot;param #%d is a uint, value: %d\\n&quot;, i, x)        case nil:            fmt.Printf(&quot;param #%d is a nil\\n&quot;, i)        case string:            fmt.Printf(&quot;param #%d is a string, value: %s\\n&quot;, i, x)        default:            fmt.Printf(&quot;param #%d&#x27;s type is unknow\\n&quot;, i)        &#125;    &#125;&#125;\n函数\n匿名函数\n未指明函数名的函数，用处：\n直接赋值给函数变量\nsumFun := func(num1, num2 int) int &#123;         return num1 + num2     &#125;     sum := sumFun(10, 20)\n直接执行\nfunc(name string) &#123;         fmt.Println(&quot;Hello&quot;, name)     &#125;(&quot;TOMOCAT&quot;)\n作为回调函数 作为参数传入函数实现不同功能\npackage mainimport (\t&quot;fmt&quot;)/*求和并调用callback函数对结果进行特殊处理*/func sumWorker(data []int, callback func(int)) &#123;\tsum := 0\tfor _, num := range data &#123;\t\tsum += num\t&#125;\tcallback(sum)&#125;func main() &#123;\t// 打印出求和结果\tsumWorker([]int&#123;1, 2, 3, 4&#125;, func(a int) &#123;\t\tfmt.Println(&quot;sum:&quot;, a)\t&#125;)\t// 判断求和结果是否大于100\tsumWorker([]int&#123;1, 2, 3, 4&#125;, func(a int) &#123;\t\tif a &gt; 100 &#123;\t\t\tfmt.Println(&quot;sum &gt; 100&quot;)\t\t&#125; else &#123;\t\t\tfmt.Println(&quot;sum &lt;= 100&quot;)\t\t&#125;\t&#125;)&#125;\n闭包\nGolang中所有的匿名函数都是闭包。\n\n闭包可以理解为一个函数“捕获”了和它处于同一作用域的其他变量\n\n类型转换\n需要注意数值之间进行转换可能造成其他问题，如精度丢失或者错误的结果\n类型断言\ninterface&#123;&#125; 类型表示一个空接口，任何类型都满足空接口。即interface&#123;&#125; 类型的值可以用于表示任意 Go 语言类型的值。将interface&#123;&#125;类型转换为需要的类型时称为类型断言。使用方法：\nvar i interface&#123;&#125; = 99 // 创建一个interface&#123;&#125;类型，其值为99j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型\n错误处理\n可以将error接口作为多返回值的最后一个\nfunc foo(param int)(ret int, err error)&#123;  ...&#125;n, err := foo(0)if err != nil &#123;    //  错误处理&#125; else &#123;    // 使用返回值n&#125;\n面向对象编程\n自定义类型\n通过结构体定义类型\ntype ColorPoint struct &#123;    color.Color     // 匿名字段(嵌入)    x, y int        // 具名字段(聚合)&#125;\n初始化对象实例\na := new(ColorPoint)a := &amp;ColorPoint&#123;&#125;a := &amp;ColorPoint&#123;&quot;Pink&quot;,18&#125;a := &amp;ColorPoint&#123;color: &quot;Pink&quot;,x: 18&#125;\n","categories":["语言学习"],"tags":["Go"]},{"title":"【算法篇】排序——快速排序（c语言）","url":"/%E7%AE%97%E6%B3%95/%E3%80%90%E7%AE%97%E6%B3%95%E7%AF%87%E3%80%91%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88c%E8%AF%AD%E8%A8%80%EF%BC%89.html","content":"【算法篇】排序——快速排序（c语言）\n核心思想\n\n排序算法的思想非常简单，在待排序的数列中，首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第 1 个数字作为基准数（其实可以随便选）。然后把这个待排序的数列中小于基准数的元素移动到它的左边，大于它的移到右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别重复上述步骤，直到各个分区只有一个数时为止。\n\n代码示例\nvoid swap(int *a, int *b)&#123;    int tmp;    tmp = *a;    *a = *b;    *b = tmp;&#125;void quick_sort(int l, int r)&#123;    int mid = in[(l + r) / 2];//这里是选择中间值作为基准    int i = l, j = r;    do    &#123;        while (in[i] &lt; mid)            i++; //找到左边比基准值大的数的位置        while (in[j] &gt; mid)            j--; //找右边小的        if (i &lt;= j)        &#123;            swap(&amp;(in[i]), &amp;(in[j])); //交换使左边的小右边的大            i++;            j--;        &#125;    &#125; while (i &lt;= j);    if(l&lt;j)        quick_sort(l, j);//排左边    if(r&gt;i)        quick_sort(i, r);//排右边&#125;\n当然了一般情况下不用自己写（毕竟有现成的）\n来看一下炒鸡好用的qsort函数\nqsort函数的用法\n函数声明\n\nvoid qsort(void *base, size_t nitems, size_t size, int (*compar)(const void , const void))\n\n参数说明\n\nbase-- 指向要排序的数组的第一个元素的指针。\nnitems-- 由 base 指向的数组中元素的个数。\nsize-- 数组中每个元素的大小，以字节为单位。\n==compar-- 用来比较两个元素的函数，即函数指针（回调函数）==\n\n\ncompar函数的形式决定了对谁排序*\n\nint compar(const voidp1, const voidp2);\n\n\n\ncompar函数的返回值\n描述\n\n\n\n\n&lt;0\np1所指向元素将被排在p2所指向元素的左面\n\n\n=0\np1所指向元素与p2所指向元素的顺序不确定\n\n\n&gt;0\np1所指向元素会被排在p2所指向元素的右面\n\n\n\n具体用法说明\n\n对一维数组\n\nint comp(const void*a,const void*b)&#123;    return *(int*)a-*(int*)b;&#125; \n\n对二维数组\n\nint comp(const void*a,const void*b)&#123;    return ((int*)a)[0]-((int*)b)[0];&#125; \n\n对字符串\n\nint Comp(const void*p1,const void*p2)&#123;    return strcmp((char*)p2,(char*)p1);&#125;int main()&#123;    char a[MAX1][MAX2];    initial(a);    qsort(a,lenth,sizeof(a[0]),Comp);    //lenth为数组a的长度 &#125;\n\n对结构体一级排序\n\nstruct Node&#123;    double data;    int other;&#125;s[100];int Comp(constvoid*p1,constvoid*p2)&#123;    return(*(Node*)p2).data&gt;(*（Node*）p1).data?1:-1;&#125;qsort(s,100,sizeof(s[0]),Comp);\n\n对结构体多级排序\n\nstruct Node&#123;    int x;    int y;&#125;s[100];//按照x从小到大排序，当x相等时按y从大到小排序int Comp(const void*p1,const void*p2)&#123;    struct Node*c=(Node*)p1;    struct Node*d=(Node*)p2;    if(c-&gt;x!=d-&gt;x)returnc-&gt;x-d-&gt;x;    else return d-&gt;y-c-&gt;y;&#125;\n\n对结构体的字符串\n\nstruct Node&#123;    int data;    char str[100];&#125;s[100];//按照结构体中字符串str的字典序排序int Comp(const void*p1,const void*p2)&#123;    return strcmp((*(Node*)p1).str,(*(Node*)p2).str);&#125;qsort(s,100,sizeof(s[0]),Comp);\n","categories":["算法笔记","排序"],"tags":["C语言","算法","快排"]},{"title":"【JavaScript学习笔记】","url":"/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/JavaScprit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","content":"\n\n创建对象\n  var person=&#123;    firstName:&quot;Bill&quot;,    lastName:&quot;Gates&quot;,    age:62,    eyeColor:&quot;blue&quot;&#125;;\n对象是易变的，定义var x=person,x与person指向同一对象，二者同时改变。\n\n\n访问对象\nperson.age 或 person[&quot;age&quot;]\n\n\n","categories":["语言学习"],"tags":["JavaScript"]},{"title":"【PHP学习笔记】","url":"/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/PHP%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","content":"\n\n$_SERVER[“PHP_SELF”]是一种超全局变量，返回当前执行脚本的文件名。\n\n\n“test_form.php” 的页面中有如下表单：\n&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&quot;PHP_SELF&quot;];?&gt;&quot;&gt;\n用户输入http://www.example.com/test_form.php转化为：\n&lt;form method=&quot;post&quot; action=&quot;test_form.php&quot;&gt;\nhttp://www.example.com/test_form.php/**%22%3E%3C**script **%3**Ealer('hacked')**%3C**/script **%3E**则转为：\n&lt;form method=&quot;post&quot; action=&quot;test_form.php&quot;/&gt;&lt;script&gt;alert(&#x27;hacked&#x27;)&lt;/script&gt;\n执行javascript代码。\n\n\n\n\nhtmlspecialchars()把特殊字符转换为HTML实体，&lt; 和 &gt; 之类的 HTML 字符会被替换为 &amp;lt; 和 &amp;gt; 。这样可防止攻击者通过在表单中注入 HTML 或 JavaScript 代码（跨站点脚本攻击）对代码进行利用。\n如何攻击该方式？\n\n\n检查函数\n&lt;?php// 定义变量并设置为空值$name = $email = $gender = $comment = $website = &quot;&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123;$name = test_input($_POST[&quot;name&quot;]);$email = test_input($_POST[&quot;email&quot;]);$website = test_input($_POST[&quot;website&quot;]);$comment = test_input($_POST[&quot;comment&quot;]);$gender = test_input($_POST[&quot;gender&quot;]);&#125;function test_input($data) &#123;$data = trim($data);$data = stripslashes($data);$data = htmlspecialchars($data);return $data;&#125;?&gt;\n\n\n","categories":["语言学习"],"tags":["PHP"]},{"title":"【Python学习笔记】","url":"/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","content":" 数字类型及操作 \n整数\n==整数无限制==\n\n\n进制\n\n\n十进制 1010，99，-217\n\n\n二进制 0b或0B开头\n\n\n八进制0o或0O\n\n\n十六进制0x或0X\n\n\n\n\n浮点数\n==浮点数间运算存在不确定尾数==（用二进制表示有误差）\n\n\n使用 roundroundround 浮点数间运算比较\n\n\n不确定尾数一般发\n\n\n\n生在10−1610^{-16}10−16左右\n\n\n\nround(x,d):round(x,d):round(x,d):对x进行四舍五入，d是小数截取位数\n&gt;&gt;&gt; round(0.1+0.2,1) == 0.3True\n\n\n\n\n采用科学计数法表示浮点数\n&lt;a&gt;e&lt;b&gt; 表示 a∗10ba*10^ba∗10b\n\n\n数值运算操作符\n\n\n\n操作符\n结果\n\n\n\n\nx/y\n浮点数结果\n\n\nx//y\n整除\n\n\nx op =y\n即x=x op y\n\n\n不同类型的数进行运算产生“最宽”的结果\n\n\n\n\n一些函数形式的数值运算功能\n\n\n\n函数及使用\n描述\n\n\n\n\nabs(x)abs(x)abs(x)\nx的绝对值\n\n\ndivmod(x,y)divmod(x,y)divmod(x,y)\n同时输出商和余数  divmod(10,3)=(3,1)\n\n\npow(x,y[,z])pow(x,y[,z])pow(x,y[,z])\n幂余，z可省略\n\n\nround(x[,d])round(x[,d])round(x[,d])\n四舍五入，保留d位，默认值为0\n\n\nmax(x1,x2,…xn)max(x_1,x_2,\\dots x_n)max(x1​,x2​,…xn​)\n返回最大值\n\n\nmin(x1,x2,…xn)min(x_1,x_2,\\dots x_n)min(x1​,x2​,…xn​)\n返回最小值\n\n\nint(x)int(x)int(x)\nx变为整数\n\n\nfloat(x)float(x)float(x)\nx变为浮点数\n\n\ncomplex(x)complex(x)complex(x)\n将x变为复数，增加虚数部分  complex(4)complex(4)complex(4)结果为4+0i4+0i4+0i\n\n\n\n","categories":["语言学习"],"tags":["python"]},{"title":"【算法篇】排序——八大排序（c语言）","url":"/%E7%AE%97%E6%B3%95/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F.html","content":"简介\n冒泡排序\n1）比较相邻的元素。如果第一个比第二个大，就交换他们两个；\n2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；\n3）针对所有的元素重复以上的步骤，除了最后一个；\n4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n选择排序\n1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；\n2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；\n3）重复第二步，直到所有元素均排序完毕。\n直接插入排序\n插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n算法步骤：\n1）将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；\n2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置(相同则插入相等元素后边)。\n希尔排序(递减增量排序算法)\n核心思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\n1）选择一个增量序列d[1]，t[2]，…，d[k]，其中d[i]&gt;d[j]，d[k]=1；\n2）按增量序列个数k，对序列进行k 趟排序；\n3）每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n堆排序\n利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n堆排序的平均时间复杂度为Ο(nlogn) 。\n算法步骤：\n1）创建一个堆H[0…n-1]\n2）把堆首（最大值）和堆尾互换\n3）把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置\n4） 重复步骤2，直到堆的尺寸为1\n快速排序\n分而治之。通过排序将序列分割为两部分，左边都是比基线条件小的数，右边都是比它大的数；然后再按照这个方法对分割后的两个序列排序。\n归并排序\n1）将需要排序的序列两两划分进行第一次组内排序；\n2）将第一步排好的组再次两两组合进行组内排序；\n3）重复以上步骤，直至最后一次排序完成；\n基数排序\n基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。\n算法分析\n1.算法排序的时间复杂度\n时间复杂度o(n^2)\n冒泡排序，选择排序，插入排序\n时间复杂度o(n*logn)\n归并排序，快速排序，堆排序，希尔排序\n时间复杂度o(n)\n基数排序\n2.算法排序的空间复杂度\no(1)\n冒泡排序，选择排序，插入排序，堆排序，希尔排序\no(nlogn)\n快速排序\no(N)\n归并排序\no(M)\n基数排序\n3.稳定性：相同值的元素排序前和排序后值保持不变\n稳定的排序算法：冒泡排序，插入排序，归并排序，基数排序；\n不稳定的排序算法：选择排序，快速排序，堆排序，希尔排序；\n4.不稳定原因\n选择排序原因：在选择最小值和位置为0的数交换的时候产生；\n快速排序原因：在随机选择相同值中间的数的，两边的相同值的不不是被划分到选择值得左边就是选择值的右边；\n堆排序原因：在每次建立大根堆后，堆顶元素会换到最后的位置上去；\n希尔排序：步长为2时，第二个1跳两部，造成了不稳定；\n5.源码\n详情见代码注释\n/***********************************************************Create date:2019.10.8Designer by:MaLCompiling environment:Microsoft Visual Studio2012************************************************************/#include &quot;sort.h&quot;#include &lt;assert.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;void Swap(int *a, int *b)&#123;\tint c = *a;\t*a = *b;\t*b = c;&#125;void Show(int *arr, int len)&#123;\tfor (int i = 0; i &lt; len; ++i)\t&#123;\t\tprintf(&quot;%d  &quot;, arr[i]);\t&#125;\tprintf(&quot;\\n&quot;);&#125;// 冒泡// O(n^2)   O(1)    稳定 void BubbleSort(int *arr, int len)&#123;\tfor (int i = 0; i &lt; len - 1; ++i)\t&#123;\t\tint flag = 0;\t\tfor (int j = 0; j &lt; len - 1 - i; ++j)\t\t&#123;\t\t\tif (arr[j] &gt; arr[j + 1])\t\t\t&#123;\t\t\t\tSwap(&amp;arr[j], &amp;arr[j + 1]);\t\t\t\tflag = 1;\t\t\t&#125;\t\t&#125;\t\tif (flag == 0)\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;&#125;// 选择// O(n^2)   O(1)    不稳定void SelectSort(int *arr, int len)&#123;\tfor (int i = 0; i &lt; len - 1; ++i)\t&#123;\t\tint min = i;\t\tfor (int j = i + 1; j &lt; len; ++j)\t\t&#123;\t\t\tif (arr[j] &lt; arr[min])\t\t\t&#123;\t\t\t\tmin = j;\t\t\t&#125;\t\t&#125;\t\tSwap(&amp;arr[i], &amp;arr[min]);\t&#125;&#125;//直接插入排序   数据越趋于有序，其效率越高// O(n^2)     O(1)    稳定//  最坏 O(n^2)   最好 O(n)void InsertSort(int *arr, int len)&#123;\tfor (int i = 1; i &lt; len; ++i)\t&#123;\t\tint tmp = arr[i];\t\tint j = 0;\t\tfor (j = i - 1; j &gt;= 0; --j)\t\t&#123;\t\t\tif (arr[j] &gt; tmp)\t\t\t&#123;\t\t\t\tarr[j + 1] = arr[j];\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tarr[j + 1] = tmp;\t&#125;&#125;static void Shell2(int *arr, int len, int d)&#123;\tfor (int k = 0; k &lt; d; ++k)\t&#123;\t\tfor (int i = d + k; i &lt; len; i += d)\t\t&#123;\t\t\tint tmp = arr[i];\t\t\tint j = i - d;\t\t\tfor (; j &gt;= 0; j -= d)\t\t\t&#123;\t\t\t\tif (arr[j] &gt; tmp)\t\t\t\t&#123;\t\t\t\t\tarr[j + d] = arr[j];\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\tarr[j + d] = tmp;\t\t&#125;\t&#125;&#125;static void Shell(int *arr, int len, int d)&#123;\tfor (int i = d; i &lt; len; ++i)\t&#123;\t\tint tmp = arr[i];\t\tint j = i - d;\t\tfor (; j &gt;= 0; j -= d)\t\t&#123;\t\t\tif (arr[j] &gt; tmp)\t\t\t&#123;\t\t\t\tarr[j + d] = arr[j];\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tarr[j + d] = tmp;\t&#125;&#125;//希尔排序//  O(n ^1.3~1.5)   O(1)    不稳定  void ShellSort(int *arr, int len)&#123;\t// 目前并没有一个合适的固定分组\t//  分组的值需要两两互质，并且最后一个分组必须为1\tint d[] = &#123; 5, 3, 1 &#125;;\tfor (int i = 0; i &lt; sizeof(d) / sizeof(d[0]); ++i)\t&#123;\t\tShell(arr, len, d[i]);\t&#125;&#125;//  O(logn)static void OneAdjust(int *arr, int len, int root)&#123;\tint i = root;\tint tmp = arr[i];\tint j = 2 * i + 1; //   left\twhile (j &lt; len)\t&#123;\t\tif (j + 1 &lt; len &amp;&amp; arr[j] &lt; arr[j + 1])\t\t&#123;\t\t\tj = j + 1; \t\t&#125;\t\t//  j 就是左右孩子中较大的哪一个\t\tif (arr[j] &gt; tmp)\t\t&#123;\t\t\tarr[i] = arr[j];\t\t\ti = j;  //  下一个子树的根\t\t\tj = 2 * i + 1; //  下一个子树的左孩子\t\t&#125;\t\telse\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\tarr[i] = tmp;&#125;//  O(nlogn) static void CreateHeap(int *arr, int len)&#123;\tint root = len / 2 - 1;\tfor (; root &gt;= 0; --root)\t&#123;\t\tOneAdjust(arr, len, root);  // O(logn)\t&#125;&#125;//堆排序//  O(nlogn)     O(1)      不稳定void HeapSort(int *arr, int len)&#123;\tCreateHeap(arr, len);  //  O(nlogn)\tfor (int i = 0; i &lt; len - 1; ++i)  // O(n)\t&#123;\t\tSwap(&amp;arr[0], &amp;arr[len - 1 - i]);\t\tOneAdjust(arr, len - i - 1, 0);  //  O(logn)\t&#125;&#125;// O(n)static  int  OneQuick(int *arr, int i,  int j)&#123;\tint tmp = arr[i];\twhile (i &lt; j)   //   保证找的整个过程  i  &lt; j\t&#123;\t\twhile (i &lt; j)   //  从后向前找比tmp小的元素  保证  i &lt; j\t\t&#123;\t\t\tif (arr[j] &lt; tmp) break;\t\t\tj--;\t\t&#125;\t\tarr[i] = arr[j];   //   当找到比tmp小的元素后，将j位置的值存储到i位置\t\twhile (i &lt; j)  //  从前向后找比tmp大的元素  保证  i &lt; j\t\t&#123;\t\t\tif (arr[i] &gt; tmp) break;\t\t\ti++;\t\t&#125;\t\tarr[j] = arr[i];  //   当找到比tmp大的元素后，将i位置的值存储到j位置\t&#125;\tarr[i] = tmp;   //   i之前的数据都比tmp小， 之后的数据都比tmp大\treturn i;&#125;// O(nlogn)     O(logn)      不稳定static void Quick(int *arr, int left, int right)&#123;\t// O(n)\tint mod = OneQuick(arr, left, right);\tif (mod - left &gt; 1)   //  i左边剩余的数据是否超过1个\t&#123;\t\tQuick(arr, left, mod - 1);\t&#125;\tif (right - mod &gt; 1)  // i右边剩余的数据是否超过1个\t&#123;\t\tQuick(arr, mod + 1, right);\t&#125;&#125;//  static void  ForQuick(int *arr, int left, int right)&#123;\tStack st;\tint size = (int)(log10((double)(right - left + 1)) / log10((double)2));\tsize = (size + 1) * sizeof(int) * 2;\tst.data = (int *)malloc(size);\tassert(st.data != NULL);\tst.top = 0;\tst.data[st.top++] = left;\tst.data[st.top++] = right;\twhile (st.top != 0)\t&#123;\t\tright = st.data[--st.top];\t\tleft = st.data[--st.top];\t\tint mod = OneQuick(arr, left, right);\t\tif (mod - left &gt; 1)\t\t&#123;\t\t\tst.data[st.top++] = left;\t\t\tst.data[st.top++] = mod - 1;\t\t&#125;\t\tif (right - mod &gt; 1)\t\t&#123;\t\t\tst.data[st.top++] = mod + 1;\t\t\tst.data[st.top++] = right;\t\t&#125;\t&#125;\tfree(st.data);&#125;//快速排序void QuickSort(int *arr, int len)&#123;\tForQuick(arr, 0, len - 1);&#125;// O(n)static void Meger(int *arr, int len,  int width, int *brr)&#123;\tint L1 = 0;\tint H1 = L1 + width - 1;\tint L2 = H1 + 1;\tint H2 = L2 + width - 1 &lt; len - 1 ? L2 + width - 1 : len - 1;\tint num = 0;\twhile (L1 &lt; len &amp;&amp; L2 &lt; len)\t&#123;\t\twhile (L1 &lt;= H1 &amp;&amp; L2 &lt;= H2)\t\t&#123;\t\t\tif (arr[L1] &lt; arr[L2])\t\t\t&#123;\t\t\t\tbrr[num++] = arr[L1++];\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tbrr[num++] = arr[L2++];\t\t\t&#125;\t\t&#125;\t\twhile (L1 &lt;= H1)\t\t&#123;\t\t\tbrr[num++] = arr[L1++];\t\t&#125;\t\twhile (L2 &lt;= H2)\t\t&#123;\t\t\tbrr[num++] = arr[L2++];\t\t&#125;\t\tL1 = H2 + 1;\t\tH1 = L1 + width - 1 &lt; len - 1 ? L1 + width - 1 : len - 1;\t\tL2 = H1 + 1;\t\tH2 = L2 + width - 1 &lt; len - 1 ? L2 + width - 1 : len - 1;\t&#125;\twhile (L1 &lt;= H1)\t&#123;\t\tbrr[num++] = arr[L1++];\t&#125;\tfor (int i = 0; i &lt; len; ++i)\t&#123;\t\tarr[i] = brr[i];\t&#125;&#125;//归并排序// O(nlogn)    O(n)     稳定void MegerSort(int *arr, int len)&#123;\tint *brr = (int *)malloc(sizeof(int)* len);\tfor (int i = 1; i &lt; len; i *= 2)\t&#123;\t\tMeger(arr, len, i, brr);   // O(n)\t&#125;\tfree(brr);&#125;//  求数组中最大数字的宽度static int  GetMaxWidth(int *arr, int len)&#123;\tint max = arr[0];\tfor (int i = 0; i &lt; len; ++i)\t&#123;\t\tif (arr[i] &gt; max)  max = arr[i];\t&#125;\tint width = 0;\twhile (max)  //  12\t&#123;\t\twidth++;\t\tmax /= 10;\t&#125;\treturn width;&#125;//  求data的倒数第i+1位上的值static int GetNumOfWidth(int data, int i)&#123;\twhile (i)\t&#123;\t\tdata /= 10;\t\ti--;\t&#125;\treturn data % 10;&#125;// O(d * n)      O(k + n)     稳定// 基数排序      不需要比较的排序void RadixSort(int *arr, int len)&#123;\t/* \t    1、创建队列\t\t2、先求最大数字的位数\t\t3、求出相应位数的值， 并根据位数值将其存储相应的队列中\t\t4、按顺序输出所有队列中的值，  循环处理3,4步，循环次数由第一步算出\t*/\tQue que[10];\tfor (int i = 0; i &lt; 10; ++i)\t&#123;\t\tque[i].data = (int*)malloc(sizeof(int)* len);\t\tassert(que[i].data != NULL);\t\tque[i].head = que[i].tail = 0;\t&#125;\tint width = GetMaxWidth(arr, len); // O(n)\tfor (int i = 0; i &lt; width; ++i)  // O(d * n)\t&#123;\t\t//  将数组中所有的数字取其相应位数的值，并将其存储到相应的队列中\t\tfor (int j = 0; j &lt; len; ++j)\t\t&#123;\t\t\tint  num = GetNumOfWidth(arr[j], i);\t\t\tque[num].data[que[num].tail++] = arr[j];\t\t&#125;\t\tint k = 0;\t\tfor (int m = 0; m &lt; 10; ++m)\t\t&#123;\t\t\twhile (que[m].head != que[m].tail)\t\t\t&#123;\t\t\t\tarr[k++] = que[m].data[que[m].head++];\t\t\t&#125;\t\t&#125;\t\tfor (int n = 0; n &lt; 10; ++n)\t\t&#123;\t\t\tque[n].head = que[n].tail = 0;\t\t&#125;\t&#125;\tfor (int i = 0; i &lt; 10; ++i)\t&#123;\t\tfree(que[i].data);\t&#125;&#125;","categories":["算法笔记","排序"],"tags":["C语言","算法","快排"]},{"title":"关于出栈序列的解法总结及卡特兰数的学习（C语言）","url":"/%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%E7%9A%84%E8%A7%A3%E6%B3%95%E6%80%BB%E7%BB%93%E5%8F%8A%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88C%E8%AF%AD%E8%A8%80%EF%BC%89.html","content":"出栈次序\n\n一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?\n\n解法1——递归/记忆化搜索\n\n考虑用一个二维数组f[i][j]模拟当前情况：i——进栈序列中还有i个待排的数，j——栈中有j个数，f[i][j]的值表示当前i,j情况下有几种输出方案。\n首先如果f[i][j]有值，直接调用即可（记忆化搜索，节省时间）；\n如果i=0，即序列全部入栈，只有一种输出方法，所以返回1；\n考虑一般情况，有两种输出方案，先进一个再出，即加上f[i-1][j+1],（栈不空时,j&gt;0,如果栈空只有第一种输出方案可行）直接出，即加上f[i][j-1]。\n\n代码如下\nlong long f[MAX][MAX];long long dfs(int i,int j)&#123;\tif(f[i][j])\t\treturn f[i][j];\tif (i == 0)\t\treturn 1;\tif(j&gt;0)\t\tf[i][j] += dfs(i, j - 1);\tf[i][j] += dfs(i - 1, j + 1);\treturn f[i][j];&#125;int main()&#123;\tint n;\tscanf(&quot;%d&quot;, &amp;n);\tprintf(&quot;%lld&quot;, dfs(n, 0));\treturn 0;&#125;\n解法2——递推\n\n首先重设一下f[i][j],f的含义不变，i为入栈数，j为出栈数；\n我们知道f[0][j]=1，因为序列全部入栈，出栈次序是唯一的。\n然后我们来考虑一下递归关系，如何得到f[i][j]?即怎么得到i个数入栈，j个数出栈的情况，只需要有i-1个数入栈，出栈j个，此时再入栈一个就是f[i][j]；同理，可以是i个数入栈，j-1个出栈。所以我们得到递归关系f[i][j]=f[i-1][j]+f[i][j-1]。\n但涉及到出栈必须考虑栈空的情况，什么时候栈空？i=j时，就只有f[i][j]=f[i-1][j]。\n\n递归做法\nlong long f[MAX_N][MAX_N];int main()&#123;\tint n;\tscanf(&quot;%d&quot;,&amp;n);\tfor(int i=0;i&lt;=n;i++)\t&#123;\t\tf[0][i]=1;\t&#125;\tfor(int i=1;i&lt;=n;i++)\t&#123;\t\tfor(int j=i;j&lt;=n;j++)\t\t&#123;\t\t\tif(i==j)f[i][j]=f[i-1][j];\t\t\telse f[i][j]=f[i][j-1]+f[i-1][j];\t\t&#125;\t&#125;\tprintf(&quot;%lld&quot;,f[n][n]);\treturn 0;&#125;\n解法3——卡特兰数\n关于卡特兰数列的详细解释移步百度百科\n\n我们可以直接用的是它的四个递推公式\n\n\n设h(n)为catalan数的第n项，令h(0)=1,h(1)=1，catalan数满足递推式 ：\n1)h(n)= h(0)*h(n-1)+h(1)*h(n-2) + … + h(n-1)h(0) (n≥2)\n2)h(n)=h(n-1) * (4n-2)/(n+1)\n3)h(n)=C(2n,n)/(n+1) (n=0,1,2,…)\n4)h(n)=C(2n,n) - C(2n,n-1) (n=0,1,2,…)\n\n代码\n都有递推关系了代码不是有手就行\n  //给出公式4作为参照long long c[MAX][MAX];int main()&#123;\tint n;    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=2*n;i++)    &#123;    \tc[i][0]=c[i][i]=1;    \tfor(int j=1;j&lt;i;j++)    \t&#123;    \t\tc[i][j]=c[i-1][j]+c[i-1][j-1];\t\t&#125;\t&#125;    printf(&quot;%lld&quot;,c[2*n][n]-c[2*n][n-1]);    return 0;&#125;\n关键是分析为什么可以用卡特兰\n\n原理分析：\n建立数组f。f[i]表示i个数的全部可能性。\nf[0] = 1, f[1] = 1; //当然只有一个\n设 x 为当前出栈序列的最后一个，则x有n种取值\n由于x是最后一个出栈的，所以可以将已经出栈的数分成两部分\n1.比x小\n2.比x大\n比x小的数有x-1个，所以这些数的全部出栈可能为f[x-1]\n比x大的数有n-x个，所以这些数的全部出栈可能为f[n-x]\n这两部分互相独立，所以根据乘法原理，一个x的取值能够得到的所有可能性为f[x-1] * f[n-x]\n另外，由于x有n个取值，所以\nans = f[0]*f[n-1] + f[1]*f[n-2] + … + f[n-1]*f[0];\n或者这样分析：\n我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。\n那么合法序列就是总序列-非法序列，总序列(由n次出栈n次入栈操作构成的序列数)为C(2n,n)。\n非法序列：由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。\n这就证明了不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。，为C(2n,n+1)\n所以有输出序列的总数目=c(2n,n)-c(2n,n-1)=c(2n,n)/(n+1)=h(n)。\n\n我觉得这类题目可以总结为==由特定顺序（二者匹配）的两种状态组成的排序数==类问题\n类似题目有\n\n括号序列  ：n 对括号，则有多少种 “括号匹配” 的括号序列\n\n——左括号看作1，右括号看作0，和上题一样\n\n二叉树n + 1 个叶子节点能够构成多少种形状不同的（国际）满二叉树\n（国际）满二叉树定义：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。\n\n——形成满二叉树需要先向左扩展，再向右扩展，左右匹配，所以向左看作1，向右看作0，n+1个叶子结点有2n次扩展，还原为出入栈\n\n买票找零：有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少种方法使得只要有10元的人买票，售票处就有5元的钞票找零\n\n——拿5元的看作1，10元的看作0\n所以要对这类题目有一定敏感性\n有关题目练习可以去：\n栈\n球迷购票问题\n鸡蛋饼\n","categories":["算法笔记"],"tags":["C语言","算法","栈"]},{"url":"/%E7%BD%91%E7%BB%9C%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C/lab2.html","content":"会议\n\n\nCVPR是 IEEE Conference on Computer Vision and Pattern Recognition的缩写，即IEEE国际 计算机视觉 与 模式识别 会议。该会议是由IEEE举办的计算机视觉和模式识别领域的顶级会议。\n\n\nUsenix Security Symposium (USENIX Security)，是网络安全领域四大最高级别的国际学术会议之一，始于上世纪90年代初，曾经发表难度极高，近几年录取量才开始放开。USENIX Security是CCF推荐A类会议，Core Conference Ranking A*类会议，H-5指数80，Impact Score 13.04。USENIX Security录用的文章基本限于hardcore systems类型。\n\n\nTransactions on Information Forensics &amp; Security\n\n\nDAC，全称 Proceedings of the ACM/EDAC/IEEE Design Automation Conference。DAC是以电子设计系统（(EDA）、嵌入式系统及软件（ESS）和知识产权（IP）为主题的大会。DAC会议是集成电路设计界最顶级的会议，被誉为EDA界的奥斯卡，是全球领先的技术性大会和电子设计设计自动化商展。DAC是CCF 推荐A类会议，Core Conference Ranking推荐C类会议，H5 index为52，Impact Score 6.93\n\n\n边松\n研究方向：特定领域加速器、应用密码学、AI安全\n论文\n\n\nSong Bian, Weiwen Jiang, and Takashi Sato, Privacy-Preserving Medical Image Segmentation via Hybrid Trusted Execution Environment, ACM/IEEE Design Automation Conference (DAC), July 2021\n通过混合可信执行环境保护隐私的医学图像分割\n\n\nSong Bian, Weiwen Jiang, Qing Lu, Yiyu Shi, and Takashi Sato, NASS: Optimizing Secure Inference via Neural Architecture Search, in Proc. of European Conference on Artificial Intelligence (ECAI) (Virtual), June 2020.\n\n\nSong Bian, Tianchen Wang, Masayuki Hiromoto, Yiyu Shi, and Takashi Sato, ENSEI: Efficient Secure Inference via Frequency-Domain Homomorphic Convolution for PrivacyPreserving Visual Recognition, in Proc. of IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR) (Virtual), pp.9403-9412, June 2020\n基于频域同态卷积的保密视觉识别的高效安全推理\n\n\n\n方向\n\n\n物联网双向认证\n基于SRAM-PUF的物联网轻量级相互认证方案\n\n\n（邓欣）Interpretable Multi-Modal Image Registration Network Based on Disentangled Convolutional Sparse Coding\n==多模态图像匹配==\n\n\n（边松）同态线性变换加速 APAS: Application-specific accelerators for RLWE-based homomorphic linear transformations\n算法加速\n\n\n==通过混合可信执行环境保护隐私的医学图像分割==\n\n\n线上问诊个人信息隐写\n\n\nAI对抗攻击的防御、视频检测、恶意内容检测\n\n\n人工智能安全现状概析\n\n\n在分析之前，我们首先来简单的介绍一下人工智能的应用。由于人工智能具有突出的数据分析、知识提取、自主学习等优点，被广泛应用在网络防护、数据管理、信息审查、智能安防、金融风控以及舆情监测等方面。在这些方面，往往存在若干安全风险，常见风险如下：\n  1.框架安全风险\n近些年来，我们熟知的深度学习框架TensorFlow、Caffe等，及其依赖库被多次发现存在安全漏洞，这些漏洞可被攻击者利用，引发系统安全问题。\n  2.数据安全风险\n攻击者可以通过网络的内部参数逆向获取网络训练的数据集；人工智能技术还会加强数据挖掘的能力，这加大了隐私泄露的风险，例如2018年3月的Facebook数据泄露事件。\n  3.算法安全风险\n对于深度学习网络目标函数定义的不准确、不合理或者不正确也可能会导致错误甚至伤害性的结果。错误的目标函数、计算成本太高的目标函数、表达能力有限的网络都可能使网络产生错误的结果。例如，2018年3月，Uber自动驾驶汽车因机器视觉系统未及时识别路上突然出现的行人，导致与行人相撞，导致行人死亡的事故。\n算法存在偏见与人工智能的不可解释性也是一个重大的问题。之前美国利用人工智能算法预测犯罪的人，名单暴露，其中许多无辜的人被冤枉，并且被冤枉的人中大多数为黑人，并且对于决策算法中系统为什么做出这样的决策，即使它的开发者也无法给出合理的解释。\n对抗性样本的出现也会使算法出现误判的情况，如下图中加入少量的噪声，AI便将熊猫以很高的置信度识别成长臂猿。\n\n  4.信息安全风险\n只要有足够的训练数据，人工智能就可以制作虚假的信息，用于不法活动。例如AI换脸技术DeepFakes，还有前段时间出现的DeepNude。一些不法分子利用虚假的语音与视频来实施zhapian。目前谷歌发明的聊天机器人在与人进行电话聊天时，已经完全能骗过人类。\n"},{"url":"/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E6%80%9D%E8%80%83%E9%A2%98/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E6%80%9D%E8%80%83%E9%A2%98.html","content":"第一章 绪论\n1-1 以无线广播和电视为例,说明图1-3模型中信源、信宿及信道包含的具体内容是什么?\n\n\n信源的作用是把各种消息转换成原始电信号。信宿是信源的逆过程\n\n\n信源：无线广播的信源是把声音转换为电信号的设备，电视的是从影像转换成电信号的设备\n信宿：无线广播的信源是把电信号转换为声音的设备，电视的是从影像转换成电信号的设备\n信道：分别是载有声音和影像的无线电波\n\n1-2 何谓数字信号?何谓模拟信号?两者的根本区别是什么?\n\n数字信号——载荷消息的信号参量只有有限个取值（电报机、计算机输出的信号）\n模拟信号——载荷消息的信号参量取值是连续的，连续指在某一取值范围内可以取无穷多个值，在时间上不一定连续。（x方向不一定连续，y方向一定连续）\n二者的根本区别是信号参量的取值是有限个还是无限个\n\n1-3 何谓数字通信?数字通信有哪些优缺点?\n\n数字通信系统是利用数字信号来传递信息的通信系统。\n优点\n\n抗干扰能力强，噪声不积累。因为只用判断是哪一个波形不用完全还原；特有抽样判决再生（？）的接收方式，使数字信号再生且噪声不积累。\n传输差错可控。信道编码技术进行查错纠错\n使用现代数字信号处理技术，可以处理来自不同信源的信号综合传输。\n\n\n\n1-4 数字通信系统的一般模型中各组成部分的主要功能是什么?\n按调制方式,通信系统如何分类?\n按传输信号的特征,通信系统如何分类?\n按复用方式,通信系统如何分类?\n1-8单工、半双工及全双工通信方式是按什么标准分类的?解释它们的工作方式并举例说明。\n并行传输和串行传输的适用场合及特点?1-9\n1-10通信系统的主要性能指标是什么?\n1-11衡量数字通信系统有效性和可靠性的性能指标有哪些?\n1-12何谓码元速率和信息速率?它们之间的关系如何?\n1 -13何谓误码率和误信率?它们之间的关系如何?\n1-14 消息中包含的信息量与以下哪些因素有关?\n(1)消息出现的概率;\n(2)消息的种类;\n(3)消息的重要程度\n"},{"title":"Github+Hexo搭建属于自己的免费博客","url":"/%E9%9A%8F%E4%BE%BF%E6%90%9E%E6%90%9E/hexo_github.html","content":"用以记录我搭建博客的完整流程：\n我选用了github+hexo框架，配以vscode作为编辑器一体化配置。基于github page生成的个人博客可以保证稳定性（不会莫名挂了），使用vscode本地编写md文件再直接使用hexo命令渲染推送到公网也比较方便。\nGithub账号准备\n新建仓库命名为github账户名.github.io\ngithub远程仓库与本机连接\nNode准备\n安装Hexo\n创建网站\nhexo new &quot;My New Post&quot;\n至此你的博客已经可以被他人以https://xxxx.github.io的形式访问到了，个人博客的雏形已基本完成，接下来是进一步优化。\n皮肤\n设置评论系统\nCDN加速\n","categories":["个人博客搭建"],"tags":["hexo"]}]